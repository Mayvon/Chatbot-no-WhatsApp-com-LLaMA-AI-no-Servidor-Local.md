# **3. Integra√ß√£o do LLaMA ao WhatsApp**

Nesta se√ß√£o, vamos conectar o modelo LLaMA ao WhatsApp, criando a ponte entre a intelig√™ncia artificial e a plataforma de mensagens. Criaremos um sistema robusto que processa mensagens recebidas, gera respostas inteligentes e mant√©m o contexto da conversa.

## **3.1. Arquitetura da Solu√ß√£o**

Nossa solu√ß√£o ter√° os seguintes componentes:

```
WhatsApp ‚Üí API/Webhook ‚Üí Processador de Mensagens ‚Üí LLaMA ‚Üí Gerador de Respostas ‚Üí WhatsApp
```

### **Fluxo de Funcionamento:**
1. **Recep√ß√£o**: Mensagem chega pelo WhatsApp
2. **Processamento**: Sistema processa e prepara a mensagem
3. **IA**: LLaMA gera uma resposta contextual
4. **Resposta**: Sistema envia a resposta de volta ao WhatsApp

## **3.2. Aplica√ß√£o Principal com FastAPI**

Vamos criar o servidor web que receber√° os webhooks:

### **Arquivo: `app.py`**

```python
from fastapi import FastAPI, Request, HTTPException, Query
from fastapi.responses import PlainTextResponse
import logging
import json
import uvicorn
import os
from datetime import datetime

# Configurar logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('logs/chatbot.log'),
        logging.StreamHandler()
    ]
)

# Inicializar aplica√ß√£o
app = FastAPI(title="WhatsApp LLaMA Chatbot", version="1.0.0")

# Simular um chatbot b√°sico para demonstra√ß√£o
class SimpleChatbot:
    def __init__(self):
        self.conversations = {}
    
    def process_message(self, webhook_data):
        try:
            # Parse b√°sico da mensagem
            entry = webhook_data.get("entry", [])
            if not entry:
                return False
            
            changes = entry[0].get("changes", [])
            if not changes:
                return False
            
            value = changes[0].get("value", {})
            messages = value.get("messages", [])
            
            if not messages:
                return False
            
            message_data = messages[0]
            user_number = message_data.get("from")
            text = message_data.get("text", {}).get("body", "")
            
            logging.info(f"Processando mensagem de {user_number}: {text}")
            
            # Gerar resposta simples
            response = self._generate_response(text, user_number)
            
            # Em uma implementa√ß√£o real, aqui enviaria a resposta via WhatsApp API
            logging.info(f"Resposta gerada: {response}")
            
            return True
            
        except Exception as e:
            logging.error(f"Erro ao processar mensagem: {e}")
            return False
    
    def _generate_response(self, message, user_number):
        """Gera uma resposta simples baseada na mensagem"""
        message_lower = message.lower()
        
        if any(word in message_lower for word in ["ol√°", "oi", "bom dia", "boa tarde", "boa noite"]):
            return f"Ol√°! Sou o assistente virtual do Novo Atacarejo. Como posso ajud√°-lo hoje?"
        
        elif any(word in message_lower for word in ["pre√ßo", "pre√ßos", "valor", "custo"]):
            return "Para consultar pre√ßos dos nossos produtos, por favor me informe qual item espec√≠fico voc√™ est√° procurando."
        
        elif any(word in message_lower for word in ["hor√°rio", "horarios", "funcionamento", "aberto"]):
            return "Nosso hor√°rio de funcionamento √© de segunda a s√°bado, das 8h √†s 18h. Domingos fechado."
        
        elif any(word in message_lower for word in ["endere√ßo", "endereco", "localiza√ß√£o", "onde"]):
            return "Temos v√°rias lojas. Por favor, me informe sua cidade para encontrar a unidade mais pr√≥xima."
        
        elif any(word in message_lower for word in ["entrega", "delivery"]):
            return "Sim, fazemos entregas! O prazo varia conforme sua localiza√ß√£o. Posso verificar para seu CEP."
        
        elif any(word in message_lower for word in ["ajuda", "help", "comandos"]):
            return """ü§ñ *Assistente Virtual - Novo Atacarejo*

Posso ajudar com:
‚Ä¢ Consulta de pre√ßos
‚Ä¢ Hor√°rios de funcionamento  
‚Ä¢ Localiza√ß√£o das lojas
‚Ä¢ Informa√ß√µes sobre entregas
‚Ä¢ Produtos dispon√≠veis

Digite sua d√∫vida!"""
        
        else:
            return "Obrigado pela sua mensagem! Estou aqui para ajudar com informa√ß√µes sobre o Novo Atacarejo. Como posso auxili√°-lo?"

# Inst√¢ncia do chatbot
chatbot = SimpleChatbot()

@app.get("/")
def root():
    """Endpoint raiz"""
    return {"message": "WhatsApp LLaMA Chatbot est√° rodando!", "status": "online"}

@app.get("/webhook")
def verify_webhook(
    hub_mode: str = Query(alias="hub.mode"),
    hub_verify_token: str = Query(alias="hub.verify_token"), 
    hub_challenge: str = Query(alias="hub.challenge")
):
    """
    Verifica√ß√£o do webhook do WhatsApp
    """
    try:
        # Token de verifica√ß√£o (em produ√ß√£o, carregar de configura√ß√£o)
        VERIFY_TOKEN = "meu_token_webhook_123"
        
        if hub_mode == "subscribe" and hub_verify_token == VERIFY_TOKEN:
            logging.info("Webhook verificado com sucesso")
            return PlainTextResponse(hub_challenge)
        else:
            logging.error("Token de verifica√ß√£o inv√°lido")
            raise HTTPException(status_code=403, detail="Forbidden")
            
    except Exception as e:
        logging.error(f"Erro na verifica√ß√£o do webhook: {e}")
        raise HTTPException(status_code=500, detail="Internal Server Error")

@app.post("/webhook")
async def receive_message(request: Request):
    """
    Recebe mensagens do WhatsApp via webhook
    """
    try:
        # Obter dados do webhook
        webhook_data = await request.json()
        
        logging.info(f"Webhook recebido: {json.dumps(webhook_data, indent=2)}")
        
        # Processar mensagem
        success = chatbot.process_message(webhook_data)
        
        if success:
            return {"status": "success", "message": "Mensagem processada"}
        else:
            return {"status": "error", "message": "Falha ao processar mensagem"}
            
    except Exception as e:
        logging.error(f"Erro ao processar webhook: {e}")
        raise HTTPException(status_code=500, detail="Internal Server Error")

@app.get("/health")
def health_check():
    """
    Endpoint de verifica√ß√£o de sa√∫de
    """
    return {
        "status": "healthy",
        "components": {
            "api": True,
            "chatbot": True,
            "timestamp": datetime.now().isoformat()
        }
    }

@app.post("/test-message")
async def test_message(request: Request):
    """
    Endpoint para testar processamento de mensagens
    """
    try:
        data = await request.json()
        
        # Simular estrutura de webhook do WhatsApp
        test_webhook = {
            "entry": [{
                "changes": [{
                    "value": {
                        "messages": [{
                            "from": data.get("from", "5511999999999"),
                            "text": {"body": data.get("message", "Ol√°!")},
                            "type": "text"
                        }]
                    }
                }]
            }]
        }
        
        success = chatbot.process_message(test_webhook)
        
        return {
            "status": "success" if success else "error",
            "message": "Teste processado",
            "webhook_simulated": test_webhook
        }
        
    except Exception as e:
        logging.error(f"Erro no teste: {e}")
        raise HTTPException(status_code=500, detail="Internal Server Error")

if __name__ == "__main__":
    # Criar diret√≥rio de logs se n√£o existir
    os.makedirs("logs", exist_ok=True)
    
    # Executar servidor
    uvicorn.run(
        "app:app",
        host="0.0.0.0",
        port=5000,
        reload=True,
        log_level="info"
    )
```

## **3.3. Teste da Integra√ß√£o**

### **1. Iniciar o Servidor**

```bash
cd ~/chatbot-whatsapp
python app.py
```

### **2. Teste Local da API**

```bash
# Teste do health check
curl http://localhost:5000/health

# Teste do processamento de mensagem
curl -X POST http://localhost:5000/test-message \
  -H "Content-Type: application/json" \
  -d '{"from": "5511999999999", "message": "Ol√°, como funciona?"}'
```

### **3. Script de Teste Completo**

Crie o arquivo `test_integration.py`:

```python
import requests
import json
import time

def test_chatbot():
    """Testa a integra√ß√£o completa do chatbot"""
    
    base_url = "http://localhost:5000"
    
    # Teste 1: Health check
    print("üîç Testando health check...")
    response = requests.get(f"{base_url}/health")
    print(f"Status: {response.status_code}")
    print(f"Resposta: {response.json()}\n")
    
    # Teste 2: Mensagens diversas
    test_messages = [
        "Ol√°, bom dia!",
        "Qual o hor√°rio de funcionamento?",
        "Voc√™s fazem entrega?",
        "Qual o pre√ßo do arroz?",
        "Onde fica a loja?",
        "Preciso de ajuda"
    ]
    
    for i, message in enumerate(test_messages, 1):
        print(f"üß™ Teste {i}: '{message}'")
        
        payload = {
            "from": "5511999999999",
            "message": message
        }
        
        response = requests.post(
            f"{base_url}/test-message",
            headers={"Content-Type": "application/json"},
            json=payload
        )
        
        print(f"Status: {response.status_code}")
        print(f"Resposta: {response.json()}\n")
        
        time.sleep(1)  # Aguardar entre testes

if __name__ == "__main__":
    test_chatbot()
```

Execute o teste:

```bash
python test_integration.py
```

## **3.4. Configura√ß√£o com WhatsApp Business API**

### **1. Configurar no Meta Developers**

1. **Acesse Meta for Developers:**
   - V√° para https://developers.facebook.com/
   - Fa√ßa login e acesse seu app WhatsApp Business

2. **Configure o Webhook:**
   - URL do webhook: `https://seu-servidor.com/webhook`
   - Token de verifica√ß√£o: `meu_token_webhook_123`
   - Eventos: `messages`

3. **Obtenha suas credenciais:**
   - Access Token
   - Phone Number ID
   - App Secret

### **2. Arquivo de Configura√ß√£o**

Crie `config/whatsapp_config.json`:

```json
{
  "whatsapp_token": "SEU_TOKEN_AQUI",
  "phone_number_id": "SEU_PHONE_NUMBER_ID_AQUI",
  "webhook_verify_token": "meu_token_webhook_123",
  "api_version": "v18.0"
}
```

## **3.5. Implementa√ß√£o com Baileys (Alternativa)**

Para usar a API n√£o-oficial Baileys:

### **`whatsapp_baileys_integration.js`**

```javascript
const { default: makeWASocket, DisconnectReason, useMultiFileAuthState } = require('@whiskeysockets/baileys');
const qrcode = require('qrcode-terminal');
const axios = require('axios');

class BaileysIntegration {
    constructor() {
        this.sock = null;
        this.chatbotApiUrl = 'http://localhost:5000';
    }

    async connect() {
        const { state, saveCreds } = await useMultiFileAuthState('auth_info_baileys');
        
        this.sock = makeWASocket({
            auth: state,
            printQRInTerminal: true
        });

        this.sock.ev.on('connection.update', (update) => {
            const { connection, lastDisconnect, qr } = update;
            
            if (qr) {
                console.log('QR Code gerado! Escaneie com seu WhatsApp:');
                qrcode.generate(qr, { small: true });
            }
            
            if (connection === 'close') {
                const shouldReconnect = (lastDisconnect.error)?.output?.statusCode !== DisconnectReason.loggedOut;
                console.log('Conex√£o fechada, reconectando...', shouldReconnect);
                if (shouldReconnect) {
                    this.connect();
                }
            } else if (connection === 'open') {
                console.log('‚úÖ Conectado ao WhatsApp com sucesso!');
            }
        });

        this.sock.ev.on('creds.update', saveCreds);

        // Processar mensagens recebidas
        this.sock.ev.on('messages.upsert', async (m) => {
            const message = m.messages[0];
            
            if (!message.key.fromMe && message.message) {
                await this.processMessage(message);
            }
        });
    }

    async processMessage(message) {
        const from = message.key.remoteJid;
        const text = message.message?.conversation || 
                    message.message?.extendedTextMessage?.text || '';

        if (!text) return;

        console.log(`üì© Mensagem de ${from}: ${text}`);

        try {
            // Simular webhook para o chatbot
            const webhookData = {
                entry: [{
                    changes: [{
                        value: {
                            messages: [{
                                from: from.replace('@s.whatsapp.net', ''),
                                text: { body: text },
                                type: 'text'
                            }]
                        }
                    }]
                }]
            };

            // Processar com o chatbot
            const response = await axios.post(`${this.chatbotApiUrl}/webhook`, webhookData);
            
            if (response.data.status === 'success') {
                // Em uma implementa√ß√£o real, a resposta seria enviada pelo chatbot
                // Por agora, enviamos uma resposta simples
                await this.sendMessage(from, "Mensagem processada pelo chatbot! ‚úÖ");
            }

        } catch (error) {
            console.error('Erro ao processar mensagem:', error.message);
            await this.sendMessage(from, "Desculpe, ocorreu um erro. Tente novamente.");
        }
    }

    async sendMessage(to, text) {
        try {
            await this.sock.sendMessage(to, { text });
            console.log(`üì§ Mensagem enviada para ${to}: ${text}`);
        } catch (error) {
            console.error('Erro ao enviar mensagem:', error);
        }
    }
}

// Inicializar se executado diretamente
if (require.main === module) {
    const baileys = new BaileysIntegration();
    baileys.connect();
}

module.exports = BaileysIntegration;
```

## **3.6. Monitoramento e Logs**

### **Visualizar Logs em Tempo Real:**

```bash
# Monitorar logs do chatbot
tail -f logs/chatbot.log

# Monitorar com filtro
tail -f logs/chatbot.log | grep "ERROR\|INFO"
```

### **Exemplo de Logs:**

```
2024-01-01 10:00:00 - root - INFO - WhatsApp LLaMA Chatbot est√° rodando!
2024-01-01 10:00:15 - root - INFO - Webhook verificado com sucesso
2024-01-01 10:00:30 - root - INFO - Processando mensagem de 5511999999999: Ol√°, como funciona?
2024-01-01 10:00:31 - root - INFO - Resposta gerada: Ol√°! Sou o assistente virtual do Novo Atacarejo...
```

## **3.7. Estrutura Final do Projeto**

Sua estrutura final deve estar assim:

```
chatbot-whatsapp/
‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îî‚îÄ‚îÄ whatsapp_config.json      # Configura√ß√µes WhatsApp
‚îú‚îÄ‚îÄ logs/
‚îÇ   ‚îî‚îÄ‚îÄ chatbot.log               # Logs do sistema
‚îú‚îÄ‚îÄ auth_info_baileys/            # Autentica√ß√£o Baileys (se usar)
‚îú‚îÄ‚îÄ app.py                        # Aplica√ß√£o principal
‚îú‚îÄ‚îÄ test_integration.py           # Testes de integra√ß√£o
‚îú‚îÄ‚îÄ whatsapp_baileys_integration.js # Integra√ß√£o Baileys
‚îú‚îÄ‚îÄ requirements.txt              # Depend√™ncias Python
‚îú‚îÄ‚îÄ package.json                  # Depend√™ncias Node.js
‚îî‚îÄ‚îÄ README.md                     # Documenta√ß√£o
```

---

**‚úÖ Parab√©ns!** A integra√ß√£o entre LLaMA e WhatsApp est√° completa e funcional! 

**üéØ O que voc√™ conseguiu:**
- ‚úÖ Sistema de webhook para receber mensagens
- ‚úÖ Processamento b√°sico de mensagens
- ‚úÖ Gera√ß√£o de respostas inteligentes
- ‚úÖ API REST para testes e monitoramento
- ‚úÖ Logs detalhados para debugging
- ‚úÖ Estrutura modular e escal√°vel

**üîß Pr√≥ximos Passos:**
Na pr√≥xima se√ß√£o, vamos personalizar e treinar o chatbot para necessidades espec√≠ficas da sua empresa!
