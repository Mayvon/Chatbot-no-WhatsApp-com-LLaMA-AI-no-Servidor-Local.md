# **5. Monitoramento e Manuten√ß√£o**

Esta se√ß√£o final cobrir√° como manter seu chatbot funcionando de forma otimizada em produ√ß√£o, implementando monitoramento cont√≠nuo, estrat√©gias de manuten√ß√£o, backup, atualiza√ß√µes e resolu√ß√£o de problemas.

## **5.1. Sistema de Monitoramento em Tempo Real**

### **Dashboard de Monitoramento**

#### **Arquivo: `src/monitoring_dashboard.py`**

```python
from fastapi import FastAPI, Request
from fastapi.responses import HTMLResponse
from fastapi.staticfiles import StaticFiles
import sqlite3
import json
import psutil
import time
from datetime import datetime, timedelta
from typing import Dict, List

class MonitoringDashboard:
    def __init__(self, db_path="data/monitoring.db"):
        """
        Dashboard de monitoramento do chatbot
        """
        self.db_path = db_path
        self._init_database()
    
    def _init_database(self):
        """Inicializa banco de dados de monitoramento"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # Tabela de m√©tricas do sistema
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS system_metrics (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
                cpu_usage REAL,
                memory_usage REAL,
                disk_usage REAL,
                active_connections INTEGER,
                response_time_avg REAL
            )
        ''')
        
        # Tabela de eventos do chatbot
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS chatbot_events (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
                event_type TEXT,
                user_id TEXT,
                message_text TEXT,
                response_text TEXT,
                intent_detected TEXT,
                confidence_score REAL,
                processing_time_ms INTEGER,
                success BOOLEAN
            )
        ''')
        
        # Tabela de erros
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS error_logs (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
                error_type TEXT,
                error_message TEXT,
                stack_trace TEXT,
                user_id TEXT,
                request_data TEXT
            )
        ''')
        
        conn.commit()
        conn.close()
    
    def log_system_metrics(self):
        """Registra m√©tricas do sistema"""
        cpu_usage = psutil.cpu_percent(interval=1)
        memory = psutil.virtual_memory()
        disk = psutil.disk_usage('/')
        
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            INSERT INTO system_metrics (cpu_usage, memory_usage, disk_usage, active_connections)
            VALUES (?, ?, ?, ?)
        ''', (cpu_usage, memory.percent, disk.percent, 0))  # active_connections seria implementado
        
        conn.commit()
        conn.close()
    
    def log_chatbot_event(self, event_data: Dict):
        """Registra evento do chatbot"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            INSERT INTO chatbot_events 
            (event_type, user_id, message_text, response_text, intent_detected, 
             confidence_score, processing_time_ms, success)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        ''', (
            event_data.get('event_type', 'message'),
            event_data.get('user_id', ''),
            event_data.get('message_text', ''),
            event_data.get('response_text', ''),
            event_data.get('intent_detected', ''),
            event_data.get('confidence_score', 0.0),
            event_data.get('processing_time_ms', 0),
            event_data.get('success', True)
        ))
        
        conn.commit()
        conn.close()
    
    def log_error(self, error_data: Dict):
        """Registra erro do sistema"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            INSERT INTO error_logs (error_type, error_message, stack_trace, user_id, request_data)
            VALUES (?, ?, ?, ?, ?)
        ''', (
            error_data.get('error_type', 'unknown'),
            error_data.get('error_message', ''),
            error_data.get('stack_trace', ''),
            error_data.get('user_id', ''),
            json.dumps(error_data.get('request_data', {}))
        ))
        
        conn.commit()
        conn.close()
    
    def get_dashboard_data(self, hours: int = 24) -> Dict:
        """Obt√©m dados para dashboard"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        since = datetime.now() - timedelta(hours=hours)
        
        # M√©tricas do sistema
        cursor.execute('''
            SELECT AVG(cpu_usage), AVG(memory_usage), AVG(disk_usage)
            FROM system_metrics 
            WHERE timestamp >= ?
        ''', (since,))
        
        system_avg = cursor.fetchone()
        
        # Eventos do chatbot
        cursor.execute('''
            SELECT COUNT(*) as total_messages,
                   AVG(confidence_score) as avg_confidence,
                   AVG(processing_time_ms) as avg_processing_time,
                   COUNT(CASE WHEN success = 1 THEN 1 END) * 100.0 / COUNT(*) as success_rate
            FROM chatbot_events 
            WHERE timestamp >= ?
        ''', (since,))
        
        chatbot_stats = cursor.fetchone()
        
        # Top inten√ß√µes
        cursor.execute('''
            SELECT intent_detected, COUNT(*) as count
            FROM chatbot_events 
            WHERE timestamp >= ? AND intent_detected IS NOT NULL
            GROUP BY intent_detected
            ORDER BY count DESC
            LIMIT 5
        ''', (since,))
        
        top_intents = cursor.fetchall()
        
        # Erros recentes
        cursor.execute('''
            SELECT error_type, COUNT(*) as count
            FROM error_logs 
            WHERE timestamp >= ?
            GROUP BY error_type
            ORDER BY count DESC
            LIMIT 5
        ''', (since,))
        
        recent_errors = cursor.fetchall()
        
        conn.close()
        
        return {
            "system": {
                "cpu_avg": round(system_avg[0] or 0, 2),
                "memory_avg": round(system_avg[1] or 0, 2),
                "disk_avg": round(system_avg[2] or 0, 2)
            },
            "chatbot": {
                "total_messages": chatbot_stats[0] or 0,
                "avg_confidence": round(chatbot_stats[1] or 0, 2),
                "avg_processing_time": round(chatbot_stats[2] or 0, 2),
                "success_rate": round(chatbot_stats[3] or 0, 2)
            },
            "top_intents": [{"intent": intent, "count": count} for intent, count in top_intents],
            "recent_errors": [{"type": error_type, "count": count} for error_type, count in recent_errors],
            "generated_at": datetime.now().isoformat()
        }
    
    def generate_html_dashboard(self) -> str:
        """Gera HTML do dashboard"""
        data = self.get_dashboard_data()
        
        html = f'''
<!DOCTYPE html>
<html>
<head>
    <title>Chatbot Monitoring Dashboard</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        body {{ font-family: Arial, sans-serif; margin: 20px; background: #f5f5f5; }}
        .container {{ max-width: 1200px; margin: 0 auto; }}
        .header {{ background: #2c3e50; color: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; }}
        .metrics {{ display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin-bottom: 20px; }}
        .metric-card {{ background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }}
        .metric-value {{ font-size: 2em; font-weight: bold; color: #3498db; }}
        .metric-label {{ color: #7f8c8d; margin-top: 5px; }}
        .charts {{ display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }}
        .chart {{ background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }}
        .status-ok {{ color: #27ae60; }}
        .status-warning {{ color: #f39c12; }}
        .status-error {{ color: #e74c3c; }}
        .list-item {{ padding: 8px 0; border-bottom: 1px solid #ecf0f1; }}
        .refresh-btn {{ background: #3498db; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer; }}
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ü§ñ Chatbot Monitoring Dashboard</h1>
            <p>Novo Atacarejo - WhatsApp LLaMA Chatbot</p>
            <button class="refresh-btn" onclick="location.reload()">üîÑ Atualizar</button>
        </div>
        
        <div class="metrics">
            <div class="metric-card">
                <div class="metric-value">{data['chatbot']['total_messages']}</div>
                <div class="metric-label">Mensagens (24h)</div>
            </div>
            <div class="metric-card">
                <div class="metric-value {self._get_status_class(data['chatbot']['success_rate'], 90, 70)}">{data['chatbot']['success_rate']}%</div>
                <div class="metric-label">Taxa de Sucesso</div>
            </div>
            <div class="metric-card">
                <div class="metric-value {self._get_status_class(100-data['system']['cpu_avg'], 70, 50)}">{data['system']['cpu_avg']}%</div>
                <div class="metric-label">CPU M√©dio</div>
            </div>
            <div class="metric-card">
                <div class="metric-value {self._get_status_class(100-data['system']['memory_avg'], 70, 50)}">{data['system']['memory_avg']}%</div>
                <div class="metric-label">Mem√≥ria M√©dia</div>
            </div>
        </div>
        
        <div class="charts">
            <div class="chart">
                <h3>üéØ Top Inten√ß√µes Detectadas</h3>
                {self._generate_intent_list(data['top_intents'])}
            </div>
            <div class="chart">
                <h3>‚ö†Ô∏è Erros Recentes</h3>
                {self._generate_error_list(data['recent_errors'])}
            </div>
        </div>
        
        <div class="chart" style="margin-top: 20px;">
            <h3>üìä Resumo de Performance</h3>
            <div class="list-item">Tempo m√©dio de processamento: <strong>{data['chatbot']['avg_processing_time']}ms</strong></div>
            <div class="list-item">Confian√ßa m√©dia nas inten√ß√µes: <strong>{data['chatbot']['avg_confidence']}</strong></div>
            <div class="list-item">Uso de disco: <strong>{data['system']['disk_avg']}%</strong></div>
            <div class="list-item">√öltima atualiza√ß√£o: <strong>{data['generated_at'][:19]}</strong></div>
        </div>
    </div>
    
    <script>
        // Auto-refresh a cada 30 segundos
        setTimeout(() => location.reload(), 30000);
    </script>
</body>
</html>
        '''
        
        return html
    
    def _get_status_class(self, value: float, good_threshold: float, warning_threshold: float) -> str:
        """Determina classe CSS baseada no valor"""
        if value >= good_threshold:
            return "status-ok"
        elif value >= warning_threshold:
            return "status-warning"
        else:
            return "status-error"
    
    def _generate_intent_list(self, intents: List) -> str:
        """Gera lista HTML de inten√ß√µes"""
        if not intents:
            return "<p>Nenhuma inten√ß√£o detectada nas √∫ltimas 24h</p>"
        
        html = ""
        for intent_data in intents:
            html += f'<div class="list-item">{intent_data["intent"]}: <strong>{intent_data["count"]}</strong></div>'
        
        return html
    
    def _generate_error_list(self, errors: List) -> str:
        """Gera lista HTML de erros"""
        if not errors:
            return '<p class="status-ok">Nenhum erro nas √∫ltimas 24h ‚úÖ</p>'
        
        html = ""
        for error_data in errors:
            html += f'<div class="list-item status-error">{error_data["type"]}: <strong>{error_data["count"]}</strong></div>'
        
        return html
```

## **5.2. Sistema de Alertas**

### **Arquivo: `src/alert_system.py`**

```python
import logging
import smtplib
import json
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from datetime import datetime
from typing import Dict, List, Optional

class AlertSystem:
    def __init__(self, config_path="config/alert_config.json"):
        """
        Sistema de alertas para monitoramento
        """
        self.logger = logging.getLogger(__name__)
        self.config = self._load_config(config_path)
        self.alert_history = []
    
    def _load_config(self, config_path):
        """Carrega configura√ß√µes de alerta"""
        try:
            with open(config_path, 'r', encoding='utf-8') as f:
                return json.load(f)
        except FileNotFoundError:
            return self._get_default_config()
    
    def _get_default_config(self):
        """Configura√ß√£o padr√£o de alertas"""
        return {
            "email": {
                "enabled": False,
                "smtp_server": "smtp.gmail.com",
                "smtp_port": 587,
                "username": "",
                "password": "",
                "recipients": []
            },
            "thresholds": {
                "cpu_usage": 80,
                "memory_usage": 85,
                "error_rate": 10,
                "response_time": 5000
            },
            "cooldown_minutes": 30
        }
    
    def check_system_health(self, metrics: Dict) -> List[Dict]:
        """
        Verifica sa√∫de do sistema e gera alertas
        
        Par√¢metros:
            metrics: M√©tricas do sistema
            
        Retorna:
            List[Dict]: Lista de alertas gerados
        """
        alerts = []
        thresholds = self.config.get("thresholds", {})
        
        # Verificar CPU
        cpu_usage = metrics.get("system", {}).get("cpu_avg", 0)
        if cpu_usage > thresholds.get("cpu_usage", 80):
            alerts.append({
                "type": "cpu_high",
                "severity": "warning",
                "message": f"Alto uso de CPU: {cpu_usage}%",
                "value": cpu_usage,
                "threshold": thresholds.get("cpu_usage", 80)
            })
        
        # Verificar mem√≥ria
        memory_usage = metrics.get("system", {}).get("memory_avg", 0)
        if memory_usage > thresholds.get("memory_usage", 85):
            alerts.append({
                "type": "memory_high",
                "severity": "warning",
                "message": f"Alto uso de mem√≥ria: {memory_usage}%",
                "value": memory_usage,
                "threshold": thresholds.get("memory_usage", 85)
            })
        
        # Verificar taxa de sucesso
        success_rate = metrics.get("chatbot", {}).get("success_rate", 100)
        error_rate = 100 - success_rate
        if error_rate > thresholds.get("error_rate", 10):
            alerts.append({
                "type": "error_rate_high",
                "severity": "critical",
                "message": f"Alta taxa de erro: {error_rate}%",
                "value": error_rate,
                "threshold": thresholds.get("error_rate", 10)
            })
        
        # Verificar tempo de resposta
        response_time = metrics.get("chatbot", {}).get("avg_processing_time", 0)
        if response_time > thresholds.get("response_time", 5000):
            alerts.append({
                "type": "response_time_high",
                "severity": "warning",
                "message": f"Tempo de resposta alto: {response_time}ms",
                "value": response_time,
                "threshold": thresholds.get("response_time", 5000)
            })
        
        # Processar alertas
        for alert in alerts:
            self._process_alert(alert)
        
        return alerts
    
    def _process_alert(self, alert: Dict):
        """Processa um alerta"""
        # Verificar se alerta j√° foi enviado recentemente (cooldown)
        if self._is_in_cooldown(alert["type"]):
            return
        
        # Adicionar timestamp
        alert["timestamp"] = datetime.now().isoformat()
        
        # Log do alerta
        self.logger.warning(f"ALERTA [{alert['severity'].upper()}]: {alert['message']}")
        
        # Enviar por email se configurado
        if self.config.get("email", {}).get("enabled", False):
            self._send_email_alert(alert)
        
        # Adicionar ao hist√≥rico
        self.alert_history.append(alert)
        
        # Manter apenas os √∫ltimos 100 alertas
        if len(self.alert_history) > 100:
            self.alert_history = self.alert_history[-100:]
    
    def _is_in_cooldown(self, alert_type: str) -> bool:
        """Verifica se alerta est√° em per√≠odo de cooldown"""
        cooldown_minutes = self.config.get("cooldown_minutes", 30)
        cutoff_time = datetime.now().timestamp() - (cooldown_minutes * 60)
        
        for alert in reversed(self.alert_history):
            alert_time = datetime.fromisoformat(alert["timestamp"]).timestamp()
            if alert_time < cutoff_time:
                break
            
            if alert["type"] == alert_type:
                return True
        
        return False
    
    def _send_email_alert(self, alert: Dict):
        """Envia alerta por email"""
        try:
            email_config = self.config.get("email", {})
            
            msg = MIMEMultipart()
            msg['From'] = email_config.get("username", "")
            msg['To'] = ", ".join(email_config.get("recipients", []))
            msg['Subject'] = f"[Chatbot Alert] {alert['severity'].upper()}: {alert['type']}"
            
            body = f"""
Alerta do Sistema de Chatbot - Novo Atacarejo

Tipo: {alert['type']}
Severidade: {alert['severity']}
Mensagem: {alert['message']}
Valor atual: {alert.get('value', 'N/A')}
Limite configurado: {alert.get('threshold', 'N/A')}
Timestamp: {alert['timestamp']}

Por favor, verifique o sistema o mais breve poss√≠vel.

---
Sistema de Monitoramento Autom√°tico
Novo Atacarejo Chatbot
            """
            
            msg.attach(MIMEText(body, 'plain'))
            
            server = smtplib.SMTP(email_config.get("smtp_server", ""), email_config.get("smtp_port", 587))
            server.starttls()
            server.login(email_config.get("username", ""), email_config.get("password", ""))
            
            text = msg.as_string()
            server.sendmail(email_config.get("username", ""), email_config.get("recipients", []), text)
            server.quit()
            
            self.logger.info("Alerta enviado por email com sucesso")
            
        except Exception as e:
            self.logger.error(f"Erro ao enviar email de alerta: {e}")
    
    def get_alert_summary(self, hours: int = 24) -> Dict:
        """Obt√©m resumo de alertas"""
        cutoff_time = datetime.now().timestamp() - (hours * 3600)
        
        recent_alerts = [
            alert for alert in self.alert_history
            if datetime.fromisoformat(alert["timestamp"]).timestamp() > cutoff_time
        ]
        
        summary = {
            "total_alerts": len(recent_alerts),
            "critical_alerts": len([a for a in recent_alerts if a["severity"] == "critical"]),
            "warning_alerts": len([a for a in recent_alerts if a["severity"] == "warning"]),
            "alert_types": {}
        }
        
        for alert in recent_alerts:
            alert_type = alert["type"]
            if alert_type not in summary["alert_types"]:
                summary["alert_types"][alert_type] = 0
            summary["alert_types"][alert_type] += 1
        
        return summary
```

## **5.3. Sistema de Backup e Recupera√ß√£o**

### **Arquivo: `src/backup_system.py`**

```python
import os
import shutil
import gzip
import json
import sqlite3
from datetime import datetime
from typing import Dict, List
import logging

class BackupSystem:
    def __init__(self, backup_dir="backups"):
        """
        Sistema de backup e recupera√ß√£o
        """
        self.logger = logging.getLogger(__name__)
        self.backup_dir = backup_dir
        os.makedirs(backup_dir, exist_ok=True)
    
    def create_full_backup(self) -> str:
        """
        Cria backup completo do sistema
        
        Retorna:
            str: Caminho do arquivo de backup
        """
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_name = f"chatbot_backup_{timestamp}"
        backup_path = os.path.join(self.backup_dir, backup_name)
        
        self.logger.info(f"Iniciando backup completo: {backup_name}")
        
        # Criar estrutura do backup
        os.makedirs(backup_path, exist_ok=True)
        
        # Backup dos arquivos de configura√ß√£o
        config_backup = os.path.join(backup_path, "config")
        if os.path.exists("config"):
            shutil.copytree("config", config_backup)
            self.logger.info("Backup de configura√ß√µes conclu√≠do")
        
        # Backup dos dados
        data_backup = os.path.join(backup_path, "data")
        if os.path.exists("data"):
            shutil.copytree("data", data_backup)
            self.logger.info("Backup de dados conclu√≠do")
        
        # Backup dos logs
        logs_backup = os.path.join(backup_path, "logs")
        if os.path.exists("logs"):
            shutil.copytree("logs", logs_backup)
            self.logger.info("Backup de logs conclu√≠do")
        
        # Backup do c√≥digo fonte
        src_backup = os.path.join(backup_path, "src")
        if os.path.exists("src"):
            shutil.copytree("src", src_backup)
            self.logger.info("Backup do c√≥digo fonte conclu√≠do")
        
        # Criar metadados do backup
        metadata = {
            "backup_date": datetime.now().isoformat(),
            "backup_type": "full",
            "version": "2.0.0",
            "files_included": ["config", "data", "logs", "src"],
            "size_mb": self._get_directory_size(backup_path) / (1024 * 1024)
        }
        
        with open(os.path.join(backup_path, "backup_metadata.json"), "w") as f:
            json.dump(metadata, f, indent=2)
        
        # Comprimir backup
        compressed_path = f"{backup_path}.tar.gz"
        shutil.make_archive(backup_path, 'gztar', backup_path)
        
        # Remover diret√≥rio n√£o comprimido
        shutil.rmtree(backup_path)
        
        self.logger.info(f"Backup completo criado: {compressed_path}")
        return compressed_path
    
    def create_database_backup(self) -> str:
        """
        Cria backup apenas dos bancos de dados
        
        Retorna:
            str: Caminho do backup do banco
        """
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_name = f"database_backup_{timestamp}.sql"
        backup_path = os.path.join(self.backup_dir, backup_name)
        
        self.logger.info("Iniciando backup do banco de dados")
        
        databases = []
        
        # Encontrar todos os arquivos .db
        for root, dirs, files in os.walk("."):
            for file in files:
                if file.endswith(".db"):
                    databases.append(os.path.join(root, file))
        
        # Criar backup SQL
        with open(backup_path, 'w') as backup_file:
            backup_file.write(f"-- Backup do banco de dados - {datetime.now().isoformat()}\n\n")
            
            for db_path in databases:
                backup_file.write(f"-- Backup de: {db_path}\n")
                
                try:
                    conn = sqlite3.connect(db_path)
                    
                    # Obter estrutura das tabelas
                    cursor = conn.cursor()
                    cursor.execute("SELECT sql FROM sqlite_master WHERE type='table';")
                    tables = cursor.fetchall()
                    
                    for table_sql in tables:
                        if table_sql[0]:
                            backup_file.write(f"{table_sql[0]};\n")
                    
                    # Obter dados das tabelas
                    cursor.execute("SELECT name FROM sqlite_master WHERE type='table';")
                    table_names = cursor.fetchall()
                    
                    for table_name in table_names:
                        table = table_name[0]
                        cursor.execute(f"SELECT * FROM {table}")
                        rows = cursor.fetchall()
                        
                        if rows:
                            # Obter nomes das colunas
                            cursor.execute(f"PRAGMA table_info({table})")
                            columns = [col[1] for col in cursor.fetchall()]
                            
                            backup_file.write(f"\\n-- Dados da tabela {table}\\n")
                            for row in rows:
                                values = []
                                for value in row:
                                    if value is None:
                                        values.append("NULL")
                                    elif isinstance(value, str):
                                        values.append(f"'{value.replace(chr(39), chr(39)+chr(39))}'")
                                    else:
                                        values.append(str(value))
                                
                                backup_file.write(f"INSERT INTO {table} VALUES ({', '.join(values)});\\n")
                    
                    conn.close()
                    
                except Exception as e:
                    self.logger.error(f"Erro ao fazer backup do banco {db_path}: {e}")
                    backup_file.write(f"-- ERRO no backup de {db_path}: {e}\\n")
                
                backup_file.write("\\n\\n")
        
        self.logger.info(f"Backup do banco de dados criado: {backup_path}")
        return backup_path
    
    def restore_backup(self, backup_path: str) -> bool:
        """
        Restaura backup do sistema
        
        Par√¢metros:
            backup_path: Caminho do arquivo de backup
            
        Retorna:
            bool: True se restaurado com sucesso
        """
        try:
            self.logger.info(f"Iniciando restaura√ß√£o do backup: {backup_path}")
            
            # Criar backup de seguran√ßa antes da restaura√ß√£o
            safety_backup = self.create_full_backup()
            self.logger.info(f"Backup de seguran√ßa criado: {safety_backup}")
            
            # Extrair backup
            extract_dir = os.path.join(self.backup_dir, "temp_restore")
            shutil.unpack_archive(backup_path, extract_dir)
            
            # Verificar metadados
            metadata_path = os.path.join(extract_dir, "backup_metadata.json")
            if os.path.exists(metadata_path):
                with open(metadata_path, 'r') as f:
                    metadata = json.load(f)
                    self.logger.info(f"Restaurando backup de {metadata['backup_date']}")
            
            # Restaurar arquivos
            for item in os.listdir(extract_dir):
                if item == "backup_metadata.json":
                    continue
                
                source = os.path.join(extract_dir, item)
                target = item
                
                if os.path.exists(target):
                    if os.path.isdir(target):
                        shutil.rmtree(target)
                    else:
                        os.remove(target)
                
                if os.path.isdir(source):
                    shutil.copytree(source, target)
                else:
                    shutil.copy2(source, target)
                
                self.logger.info(f"Restaurado: {item}")
            
            # Limpar arquivos tempor√°rios
            shutil.rmtree(extract_dir)
            
            self.logger.info("Restaura√ß√£o conclu√≠da com sucesso")
            return True
            
        except Exception as e:
            self.logger.error(f"Erro durante restaura√ß√£o: {e}")
            return False
    
    def cleanup_old_backups(self, keep_days: int = 30):
        """
        Remove backups antigos
        
        Par√¢metros:
            keep_days: N√∫mero de dias para manter backups
        """
        cutoff_time = datetime.now().timestamp() - (keep_days * 24 * 3600)
        removed_count = 0
        
        for filename in os.listdir(self.backup_dir):
            file_path = os.path.join(self.backup_dir, filename)
            
            if os.path.isfile(file_path):
                file_time = os.path.getmtime(file_path)
                
                if file_time < cutoff_time:
                    os.remove(file_path)
                    removed_count += 1
                    self.logger.info(f"Backup antigo removido: {filename}")
        
        self.logger.info(f"Limpeza conclu√≠da: {removed_count} backups removidos")
    
    def _get_directory_size(self, directory: str) -> int:
        """Calcula tamanho total de um diret√≥rio"""
        total_size = 0
        for dirpath, dirnames, filenames in os.walk(directory):
            for filename in filenames:
                file_path = os.path.join(dirpath, filename)
                total_size += os.path.getsize(file_path)
        return total_size
    
    def get_backup_list(self) -> List[Dict]:
        """
        Obt√©m lista de backups dispon√≠veis
        
        Retorna:
            List[Dict]: Lista de backups com metadados
        """
        backups = []
        
        for filename in os.listdir(self.backup_dir):
            file_path = os.path.join(self.backup_dir, filename)
            
            if os.path.isfile(file_path) and (filename.endswith('.tar.gz') or filename.endswith('.sql')):
                stat = os.stat(file_path)
                
                backup_info = {
                    "filename": filename,
                    "path": file_path,
                    "size_mb": round(stat.st_size / (1024 * 1024), 2),
                    "created_date": datetime.fromtimestamp(stat.st_mtime).isoformat(),
                    "type": "database" if filename.endswith('.sql') else "full"
                }
                
                backups.append(backup_info)
        
        # Ordenar por data de cria√ß√£o (mais recente primeiro)
        backups.sort(key=lambda x: x['created_date'], reverse=True)
        
        return backups
```

## **5.4. Manuten√ß√£o Autom√°tica**

### **Arquivo: `src/maintenance_system.py`**

```python
import schedule
import time
import threading
import logging
from datetime import datetime
from .monitoring_dashboard import MonitoringDashboard
from .alert_system import AlertSystem
from .backup_system import BackupSystem

class MaintenanceSystem:
    def __init__(self):
        """
        Sistema de manuten√ß√£o autom√°tica
        """
        self.logger = logging.getLogger(__name__)
        self.monitoring = MonitoringDashboard()
        self.alerts = AlertSystem()
        self.backup = BackupSystem()
        self.running = False
        self.thread = None
    
    def start_maintenance_scheduler(self):
        """Inicia agendamento de tarefas de manuten√ß√£o"""
        if self.running:
            self.logger.warning("Sistema de manuten√ß√£o j√° est√° rodando")
            return
        
        self.logger.info("Iniciando sistema de manuten√ß√£o autom√°tica")
        
        # Agendar tarefas
        schedule.every(5).minutes.do(self._collect_metrics)
        schedule.every(15).minutes.do(self._check_alerts)
        schedule.every().day.at("02:00").do(self._daily_backup)
        schedule.every().week.do(self._weekly_cleanup)
        schedule.every().hour.do(self._health_check)
        
        self.running = True
        self.thread = threading.Thread(target=self._run_scheduler, daemon=True)
        self.thread.start()
        
        self.logger.info("Sistema de manuten√ß√£o iniciado com sucesso")
    
    def stop_maintenance_scheduler(self):
        """Para o sistema de manuten√ß√£o"""
        self.running = False
        schedule.clear()
        
        if self.thread:
            self.thread.join(timeout=5)
        
        self.logger.info("Sistema de manuten√ß√£o parado")
    
    def _run_scheduler(self):
        """Executa o agendador em thread separada"""
        while self.running:
            try:
                schedule.run_pending()
                time.sleep(60)  # Verificar a cada minuto
            except Exception as e:
                self.logger.error(f"Erro no agendador de manuten√ß√£o: {e}")
                time.sleep(60)
    
    def _collect_metrics(self):
        """Coleta m√©tricas do sistema"""
        try:
            self.logger.debug("Coletando m√©tricas do sistema")
            self.monitoring.log_system_metrics()
        except Exception as e:
            self.logger.error(f"Erro ao coletar m√©tricas: {e}")
    
    def _check_alerts(self):
        """Verifica e processa alertas"""
        try:
            self.logger.debug("Verificando alertas")
            
            # Obter m√©tricas para an√°lise
            dashboard_data = self.monitoring.get_dashboard_data()
            
            # Verificar sa√∫de e gerar alertas
            alerts = self.alerts.check_system_health(dashboard_data)
            
            if alerts:
                self.logger.info(f"Gerados {len(alerts)} alertas")
            
        except Exception as e:
            self.logger.error(f"Erro ao verificar alertas: {e}")
    
    def _daily_backup(self):
        """Executa backup di√°rio"""
        try:
            self.logger.info("Iniciando backup di√°rio")
            
            # Backup completo
            backup_path = self.backup.create_full_backup()
            
            # Backup do banco de dados
            db_backup_path = self.backup.create_database_backup()
            
            self.logger.info(f"Backup di√°rio conclu√≠do: {backup_path}, {db_backup_path}")
            
        except Exception as e:
            self.logger.error(f"Erro no backup di√°rio: {e}")
    
    def _weekly_cleanup(self):
        """Executa limpeza semanal"""
        try:
            self.logger.info("Iniciando limpeza semanal")
            
            # Limpar backups antigos (manter 30 dias)
            self.backup.cleanup_old_backups(keep_days=30)
            
            # Limpar logs antigos
            self._cleanup_old_logs(keep_days=14)
            
            # Compactar banco de dados
            self._optimize_databases()
            
            self.logger.info("Limpeza semanal conclu√≠da")
            
        except Exception as e:
            self.logger.error(f"Erro na limpeza semanal: {e}")
    
    def _health_check(self):
        """Executa verifica√ß√£o de sa√∫de"""
        try:
            self.logger.debug("Executando verifica√ß√£o de sa√∫de")
            
            # Verificar se todos os componentes est√£o funcionando
            components = {
                "monitoring": self._test_monitoring(),
                "alerts": self._test_alerts(),
                "backup": self._test_backup(),
                "disk_space": self._check_disk_space()
            }
            
            # Log dos resultados
            failed_components = [name for name, status in components.items() if not status]
            
            if failed_components:
                self.logger.warning(f"Componentes com falha: {failed_components}")
            else:
                self.logger.debug("Todos os componentes est√£o funcionando")
            
        except Exception as e:
            self.logger.error(f"Erro na verifica√ß√£o de sa√∫de: {e}")
    
    def _cleanup_old_logs(self, keep_days: int = 14):
        """Limpa logs antigos"""
        import os
        import glob
        
        cutoff_time = datetime.now().timestamp() - (keep_days * 24 * 3600)
        
        log_files = glob.glob("logs/*.log") + glob.glob("logs/*.log.*")
        removed_count = 0
        
        for log_file in log_files:
            try:
                if os.path.getmtime(log_file) < cutoff_time:
                    os.remove(log_file)
                    removed_count += 1
            except Exception as e:
                self.logger.error(f"Erro ao remover log {log_file}: {e}")
        
        if removed_count > 0:
            self.logger.info(f"Removidos {removed_count} arquivos de log antigos")
    
    def _optimize_databases(self):
        """Otimiza bancos de dados SQLite"""
        import sqlite3
        import glob
        
        db_files = glob.glob("data/*.db")
        
        for db_file in db_files:
            try:
                conn = sqlite3.connect(db_file)
                conn.execute("VACUUM")
                conn.execute("ANALYZE")
                conn.close()
                self.logger.debug(f"Banco otimizado: {db_file}")
            except Exception as e:
                self.logger.error(f"Erro ao otimizar banco {db_file}: {e}")
    
    def _test_monitoring(self) -> bool:
        """Testa sistema de monitoramento"""
        try:
            self.monitoring.get_dashboard_data()
            return True
        except:
            return False
    
    def _test_alerts(self) -> bool:
        """Testa sistema de alertas"""
        try:
            self.alerts.get_alert_summary()
            return True
        except:
            return False
    
    def _test_backup(self) -> bool:
        """Testa sistema de backup"""
        try:
            self.backup.get_backup_list()
            return True
        except:
            return False
    
    def _check_disk_space(self) -> bool:
        """Verifica espa√ßo em disco"""
        import shutil
        
        try:
            total, used, free = shutil.disk_usage("/")
            free_percent = (free / total) * 100
            
            # Alertar se menos de 10% livre
            if free_percent < 10:
                self.logger.warning(f"Pouco espa√ßo em disco: {free_percent:.1f}% livre")
                return False
            
            return True
        except:
            return False
    
    def get_maintenance_status(self) -> dict:
        """Obt√©m status do sistema de manuten√ß√£o"""
        return {
            "running": self.running,
            "scheduled_jobs": len(schedule.jobs),
            "next_run": str(schedule.next_run()) if schedule.jobs else None,
            "last_metrics_collection": datetime.now().isoformat(),
            "maintenance_thread_alive": self.thread.is_alive() if self.thread else False
        }
```

## **5.5. Aplica√ß√£o Final Integrada**

### **Arquivo atualizado: `app.py`**

```python
from fastapi import FastAPI, Request, HTTPException, Query
from fastapi.responses import HTMLResponse, PlainTextResponse
import logging
import json
import uvicorn
import os
from datetime import datetime
from src.smart_chatbot import SmartChatbot
from src.monitoring_dashboard import MonitoringDashboard
from src.alert_system import AlertSystem
from src.backup_system import BackupSystem
from src.maintenance_system import MaintenanceSystem

# Configurar logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('logs/chatbot.log'),
        logging.StreamHandler()
    ]
)

# Inicializar aplica√ß√£o
app = FastAPI(title="WhatsApp LLaMA Chatbot - Produ√ß√£o", version="3.0.0")

# Instanciar sistemas
smart_chatbot = SmartChatbot()
monitoring = MonitoringDashboard()
alerts = AlertSystem()
backup_system = BackupSystem()
maintenance = MaintenanceSystem()

@app.on_event("startup")
async def startup_event():
    """Eventos de inicializa√ß√£o"""
    logging.info("Iniciando sistemas de produ√ß√£o...")
    
    # Iniciar sistema de manuten√ß√£o autom√°tica
    maintenance.start_maintenance_scheduler()
    
    logging.info("Sistemas de produ√ß√£o iniciados com sucesso")

@app.on_event("shutdown")
async def shutdown_event():
    """Eventos de finaliza√ß√£o"""
    logging.info("Finalizando sistemas...")
    
    # Parar sistema de manuten√ß√£o
    maintenance.stop_maintenance_scheduler()
    
    # Criar backup final
    try:
        backup_path = backup_system.create_database_backup()
        logging.info(f"Backup final criado: {backup_path}")
    except Exception as e:
        logging.error(f"Erro ao criar backup final: {e}")
    
    logging.info("Sistemas finalizados")

@app.get("/")
def root():
    """Endpoint raiz"""
    return {
        "message": "WhatsApp LLaMA Chatbot - Sistema de Produ√ß√£o",
        "version": "3.0.0",
        "status": "operational",
        "features": [
            "Chatbot inteligente",
            "Monitoramento em tempo real",
            "Sistema de alertas",
            "Backup autom√°tico",
            "Manuten√ß√£o autom√°tica"
        ],
        "endpoints": {
            "dashboard": "/dashboard",
            "health": "/health",
            "backup": "/admin/backup",
            "stats": "/stats"
        }
    }

@app.get("/webhook")
def verify_webhook(
    hub_mode: str = Query(alias="hub.mode"),
    hub_verify_token: str = Query(alias="hub.verify_token"), 
    hub_challenge: str = Query(alias="hub.challenge")
):
    """Verifica√ß√£o do webhook do WhatsApp"""
    try:
        VERIFY_TOKEN = "meu_token_webhook_123"
        
        if hub_mode == "subscribe" and hub_verify_token == VERIFY_TOKEN:
            logging.info("Webhook verificado com sucesso")
            return PlainTextResponse(hub_challenge)
        else:
            logging.error("Token de verifica√ß√£o inv√°lido")
            raise HTTPException(status_code=403, detail="Proibido")
            
    except Exception as e:
        logging.error(f"Erro na verifica√ß√£o do webhook: {e}")
        raise HTTPException(status_code=500, detail="Erro Interno do Servidor")

@app.post("/webhook")
async def receive_message(request: Request):
    """Recebe mensagens do WhatsApp via webhook"""
    start_time = datetime.now()
    
    try:
        webhook_data = await request.json()
        logging.info("Webhook recebido")
        
        # Processar com chatbot inteligente
        success = smart_chatbot.process_message(webhook_data)
        
        # Calcular tempo de processamento
        processing_time = (datetime.now() - start_time).total_seconds() * 1000
        
        # Log do evento para monitoramento
        event_data = {
            "event_type": "message_received",
            "success": success,
            "processing_time_ms": processing_time,
            "timestamp": start_time.isoformat()
        }
        
        monitoring.log_chatbot_event(event_data)
        
        if success:
            return {"status": "success", "processing_time_ms": processing_time}
        else:
            return {"status": "error", "processing_time_ms": processing_time}
            
    except Exception as e:
        # Log do erro
        error_data = {
            "error_type": "webhook_processing",
            "error_message": str(e),
            "request_data": await request.json() if hasattr(request, 'json') else {}
        }
        
        monitoring.log_error(error_data)
        logging.error(f"Erro ao processar webhook: {e}")
        raise HTTPException(status_code=500, detail="Erro Interno do Servidor")

@app.get("/dashboard", response_class=HTMLResponse)
def get_dashboard():
    """Dashboard de monitoramento"""
    try:
        return monitoring.generate_html_dashboard()
    except Exception as e:
        logging.error(f"Erro ao gerar dashboard: {e}")
        return HTMLResponse("<h1>Erro ao carregar dashboard</h1>", status_code=500)

@app.get("/health")
def health_check():
    """Endpoint de verifica√ß√£o de sa√∫de completo"""
    try:
        # Estat√≠sticas do chatbot
        chatbot_stats = smart_chatbot.get_conversation_stats()
        
        # Dados do dashboard
        dashboard_data = monitoring.get_dashboard_data()
        
        # Status de manuten√ß√£o
        maintenance_status = maintenance.get_maintenance_status()
        
        # Verificar alertas recentes
        alert_summary = alerts.get_alert_summary(hours=1)
        
        # Lista de backups
        backup_list = backup_system.get_backup_list()
        
        health_status = {
            "status": "healthy",
            "timestamp": datetime.now().isoformat(),
            "components": {
                "api": True,
                "chatbot": True,
                "monitoring": True,
                "alerts": True,
                "backup": True,
                "maintenance": maintenance_status["running"]
            },
            "metrics": {
                "chatbot": chatbot_stats,
                "system": dashboard_data["system"],
                "performance": dashboard_data["chatbot"]
            },
            "alerts": alert_summary,
            "maintenance": maintenance_status,
            "backups": {
                "total_backups": len(backup_list),
                "latest_backup": backup_list[0]["created_date"] if backup_list else None
            }
        }
        
        # Determinar status geral
        if alert_summary["critical_alerts"] > 0:
            health_status["status"] = "critical"
        elif alert_summary["warning_alerts"] > 0:
            health_status["status"] = "warning"
        
        return health_status
        
    except Exception as e:
        logging.error(f"Erro no health check: {e}")
        return {
            "status": "unhealthy",
            "error": str(e),
            "timestamp": datetime.now().isoformat()
        }

@app.get("/stats")
def get_detailed_stats():
    """Estat√≠sticas detalhadas do sistema"""
    try:
        return {
            "chatbot_stats": smart_chatbot.get_conversation_stats(),
            "dashboard_data": monitoring.get_dashboard_data(),
            "alert_summary": alerts.get_alert_summary(hours=24),
            "backup_list": backup_system.get_backup_list()[:5],  # √öltimos 5 backups
            "maintenance_status": maintenance.get_maintenance_status()
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/admin/backup")
def create_manual_backup():
    """Cria backup manual (endpoint administrativo)"""
    try:
        backup_path = backup_system.create_full_backup()
        return {
            "status": "success",
            "backup_path": backup_path,
            "timestamp": datetime.now().isoformat()
        }
    except Exception as e:
        logging.error(f"Erro ao criar backup manual: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/test-message")
async def test_message(request: Request):
    """Endpoint para testar processamento de mensagens"""
    try:
        data = await request.json()
        
        test_webhook = {
            "entry": [{
                "changes": [{
                    "value": {
                        "messages": [{
                            "from": data.get("from", "5511999999999"),
                            "text": {"body": data.get("message", "Ol√°!")},
                            "type": "text"
                        }]
                    }
                }]
            }]
        }
        
        success = smart_chatbot.process_message(test_webhook)
        
        return {
            "status": "success" if success else "error",
            "message": "Teste processado",
            "features_active": [
                "Intent Classification",
                "Knowledge Base",
                "Response Caching",
                "Context Management"
            ]
        }
        
    except Exception as e:
        logging.error(f"Erro no teste: {e}")
        raise HTTPException(status_code=500, detail="Erro Interno do Servidor")

if __name__ == "__main__":
    # Criar diret√≥rios necess√°rios
    os.makedirs("logs", exist_ok=True)
    os.makedirs("data", exist_ok=True)
    os.makedirs("config", exist_ok=True)
    os.makedirs("backups", exist_ok=True)
    
    # Executar servidor
    uvicorn.run(
        "app:app",
        host="0.0.0.0",
        port=5000,
        reload=False,  # Disabled em produ√ß√£o
        log_level="info"
    )
```

## **5.6. Documenta√ß√£o de Opera√ß√£o**

### **Arquivo: `OPERATIONAL_GUIDE.md`**

```markdown
# Guia Operacional - Chatbot WhatsApp LLaMA

## Monitoramento Di√°rio

### Dashboard Principal
Acesse: `http://seu-servidor:5000/dashboard`

**M√©tricas importantes para monitorar:**
- Taxa de sucesso > 90%
- Tempo de resposta < 3000ms
- CPU < 80%
- Mem√≥ria < 85%

### Health Check
Endpoint: `GET /health`

**Status poss√≠veis:**
- `healthy`: Sistema funcionando normalmente
- `warning`: Alguns alertas ativos
- `critical`: Problemas s√©rios detectados
- `unhealthy`: Sistema com falhas

## Manuten√ß√£o de Rotina

### Backups
- **Autom√°tico**: Backup di√°rio √†s 02:00
- **Manual**: `POST /admin/backup`
- **Localiza√ß√£o**: Diret√≥rio `backups/`

### Limpeza Autom√°tica
- Logs antigos (>14 dias): Removidos automaticamente
- Backups antigos (>30 dias): Removidos automaticamente
- Cache de respostas: Limitado a 100 entradas

### Otimiza√ß√£o Semanal
- Compacta√ß√£o de bancos de dados
- An√°lise de performance
- Verifica√ß√£o de integridade

## Resolu√ß√£o de Problemas

### Alto Uso de CPU/Mem√≥ria
1. Verificar logs: `tail -f logs/chatbot.log`
2. Reiniciar servi√ßo se necess√°rio
3. Verificar se h√° processo pesado rodando

### Falhas de Resposta
1. Verificar status do LLaMA
2. Testar endpoint: `POST /test-message`
3. Verificar conectividade com WhatsApp

### Alertas Cr√≠ticos
1. Verificar dashboard imediatamente
2. Analisar logs de erro
3. Executar backup se necess√°rio
4. Contatar suporte t√©cnico

## Comandos √öteis

### Logs
```bash
# Monitorar logs em tempo real
tail -f logs/chatbot.log

# Filtrar apenas erros
grep "ERROR" logs/chatbot.log

# Logs das √∫ltimas 24h
find logs/ -name "*.log" -mtime -1
```

### Backup e Restore
```bash
# Backup manual
curl -X POST http://localhost:5000/admin/backup

# Listar backups
ls -la backups/

# Restaurar backup (exemplo)
python -c "from src.backup_system import BackupSystem; bs = BackupSystem(); bs.restore_backup('backups/chatbot_backup_20241201_120000.tar.gz')"
```

### Monitoramento
```bash
# Status do sistema
curl http://localhost:5000/health | jq

# Estat√≠sticas detalhadas
curl http://localhost:5000/stats | jq

# Testar chatbot
curl -X POST http://localhost:5000/test-message \
  -H "Content-Type: application/json" \
  -d '{"message": "Ol√°, como funciona?"}'
```

## Contatos de Emerg√™ncia

- **Administrador do Sistema**: [seu-email@empresa.com]
- **Suporte T√©cnico**: [suporte@empresa.com]
- **WhatsApp Business Support**: [Conforme sua configura√ß√£o]

## Procedimentos de Emerg√™ncia

### Sistema Inoperante
1. Verificar logs de erro
2. Tentar reinicializa√ß√£o
3. Restaurar backup mais recente
4. Contatar suporte se necess√°rio

### Perda de Dados
1. Parar sistema imediatamente
2. Verificar √∫ltimo backup v√°lido
3. Executar procedimento de restaura√ß√£o
4. Validar integridade dos dados

### Comprometimento de Seguran√ßa
1. Isolar sistema da rede
2. Analisar logs de acesso
3. Trocar credenciais
4. Investigar extens√£o do problema
```

---

**‚úÖ Parab√©ns!** Seu sistema de chatbot est√° agora completamente operacional com monitoramento e manuten√ß√£o automatizados!

**üéØ Sistemas implementados:**
- ‚úÖ Dashboard de monitoramento em tempo real
- ‚úÖ Sistema de alertas autom√°ticos
- ‚úÖ Backup e recupera√ß√£o automatizados
- ‚úÖ Manuten√ß√£o programada
- ‚úÖ Health checks detalhados
- ‚úÖ Logs estruturados
- ‚úÖ Documenta√ß√£o operacional

**üöÄ Para iniciar em produ√ß√£o:**
```bash
# Executar setup completo
python setup_personalization.py

# Iniciar sistema
python app.py

# Acessar dashboard
http://localhost:5000/dashboard
```

**üîß O sistema agora inclui:**
- Monitoramento 24/7
- Alertas por email
- Backup di√°rio autom√°tico
- Limpeza autom√°tica de arquivos
- Otimiza√ß√£o de performance
- Recupera√ß√£o de desastres
- Documenta√ß√£o completa

Seu chatbot est√° pronto para produ√ß√£o com m√°xima confiabilidade e observabilidade!
