# **5. Monitoramento e Manutenção**

Esta seção final cobrirá como manter seu chatbot funcionando de forma otimizada em produção, implementando monitoramento contínuo, estratégias de manutenção, backup, atualizações e resolução de problemas.

## **5.1. Sistema de Monitoramento em Tempo Real**

### **Dashboard de Monitoramento**

#### **Arquivo: `src/monitoring_dashboard.py`**

```python
from fastapi import FastAPI, Request
from fastapi.responses import HTMLResponse
from fastapi.staticfiles import StaticFiles
import sqlite3
import json
import psutil
import time
from datetime import datetime, timedelta
from typing import Dict, List

class MonitoringDashboard:
    def __init__(self, db_path="data/monitoring.db"):
        """
        Dashboard de monitoramento do chatbot
        """
        self.db_path = db_path
        self._init_database()
    
    def _init_database(self):
        """Inicializa banco de dados de monitoramento"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # Tabela de métricas do sistema
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS system_metrics (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
                cpu_usage REAL,
                memory_usage REAL,
                disk_usage REAL,
                active_connections INTEGER,
                response_time_avg REAL
            )
        ''')
        
        # Tabela de eventos do chatbot
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS chatbot_events (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
                event_type TEXT,
                user_id TEXT,
                message_text TEXT,
                response_text TEXT,
                intent_detected TEXT,
                confidence_score REAL,
                processing_time_ms INTEGER,
                success BOOLEAN
            )
        ''')
        
        # Tabela de erros
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS error_logs (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
                error_type TEXT,
                error_message TEXT,
                stack_trace TEXT,
                user_id TEXT,
                request_data TEXT
            )
        ''')
        
        conn.commit()
        conn.close()
    
    def log_system_metrics(self):
        """Registra métricas do sistema"""
        cpu_usage = psutil.cpu_percent(interval=1)
        memory = psutil.virtual_memory()
        disk = psutil.disk_usage('/')
        
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            INSERT INTO system_metrics (cpu_usage, memory_usage, disk_usage, active_connections)
            VALUES (?, ?, ?, ?)
        ''', (cpu_usage, memory.percent, disk.percent, 0))  # active_connections seria implementado
        
        conn.commit()
        conn.close()
    
    def log_chatbot_event(self, event_data: Dict):
        """Registra evento do chatbot"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            INSERT INTO chatbot_events 
            (event_type, user_id, message_text, response_text, intent_detected, 
             confidence_score, processing_time_ms, success)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        ''', (
            event_data.get('event_type', 'message'),
            event_data.get('user_id', ''),
            event_data.get('message_text', ''),
            event_data.get('response_text', ''),
            event_data.get('intent_detected', ''),
            event_data.get('confidence_score', 0.0),
            event_data.get('processing_time_ms', 0),
            event_data.get('success', True)
        ))
        
        conn.commit()
        conn.close()
    
    def log_error(self, error_data: Dict):
        """Registra erro do sistema"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            INSERT INTO error_logs (error_type, error_message, stack_trace, user_id, request_data)
            VALUES (?, ?, ?, ?, ?)
        ''', (
            error_data.get('error_type', 'unknown'),
            error_data.get('error_message', ''),
            error_data.get('stack_trace', ''),
            error_data.get('user_id', ''),
            json.dumps(error_data.get('request_data', {}))
        ))
        
        conn.commit()
        conn.close()
    
    def get_dashboard_data(self, hours: int = 24) -> Dict:
        """Obtém dados para dashboard"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        since = datetime.now() - timedelta(hours=hours)
        
        # Métricas do sistema
        cursor.execute('''
            SELECT AVG(cpu_usage), AVG(memory_usage), AVG(disk_usage)
            FROM system_metrics 
            WHERE timestamp >= ?
        ''', (since,))
        
        system_avg = cursor.fetchone()
        
        # Eventos do chatbot
        cursor.execute('''
            SELECT COUNT(*) as total_messages,
                   AVG(confidence_score) as avg_confidence,
                   AVG(processing_time_ms) as avg_processing_time,
                   COUNT(CASE WHEN success = 1 THEN 1 END) * 100.0 / COUNT(*) as success_rate
            FROM chatbot_events 
            WHERE timestamp >= ?
        ''', (since,))
        
        chatbot_stats = cursor.fetchone()
        
        # Top intenções
        cursor.execute('''
            SELECT intent_detected, COUNT(*) as count
            FROM chatbot_events 
            WHERE timestamp >= ? AND intent_detected IS NOT NULL
            GROUP BY intent_detected
            ORDER BY count DESC
            LIMIT 5
        ''', (since,))
        
        top_intents = cursor.fetchall()
        
        # Erros recentes
        cursor.execute('''
            SELECT error_type, COUNT(*) as count
            FROM error_logs 
            WHERE timestamp >= ?
            GROUP BY error_type
            ORDER BY count DESC
            LIMIT 5
        ''', (since,))
        
        recent_errors = cursor.fetchall()
        
        conn.close()
        
        return {
            "system": {
                "cpu_avg": round(system_avg[0] or 0, 2),
                "memory_avg": round(system_avg[1] or 0, 2),
                "disk_avg": round(system_avg[2] or 0, 2)
            },
            "chatbot": {
                "total_messages": chatbot_stats[0] or 0,
                "avg_confidence": round(chatbot_stats[1] or 0, 2),
                "avg_processing_time": round(chatbot_stats[2] or 0, 2),
                "success_rate": round(chatbot_stats[3] or 0, 2)
            },
            "top_intents": [{"intent": intent, "count": count} for intent, count in top_intents],
            "recent_errors": [{"type": error_type, "count": count} for error_type, count in recent_errors],
            "generated_at": datetime.now().isoformat()
        }
    
    def generate_html_dashboard(self) -> str:
        """Gera HTML do dashboard"""
        data = self.get_dashboard_data()
        
        html = f'''
<!DOCTYPE html>
<html>
<head>
    <title>Chatbot Monitoring Dashboard</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        body {{ font-family: Arial, sans-serif; margin: 20px; background: #f5f5f5; }}
        .container {{ max-width: 1200px; margin: 0 auto; }}
        .header {{ background: #2c3e50; color: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; }}
        .metrics {{ display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin-bottom: 20px; }}
        .metric-card {{ background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }}
        .metric-value {{ font-size: 2em; font-weight: bold; color: #3498db; }}
        .metric-label {{ color: #7f8c8d; margin-top: 5px; }}
        .charts {{ display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }}
        .chart {{ background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }}
        .status-ok {{ color: #27ae60; }}
        .status-warning {{ color: #f39c12; }}
        .status-error {{ color: #e74c3c; }}
        .list-item {{ padding: 8px 0; border-bottom: 1px solid #ecf0f1; }}
        .refresh-btn {{ background: #3498db; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer; }}
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🤖 Chatbot Monitoring Dashboard</h1>
            <p>Novo Atacarejo - WhatsApp LLaMA Chatbot</p>
            <button class="refresh-btn" onclick="location.reload()">🔄 Atualizar</button>
        </div>
        
        <div class="metrics">
            <div class="metric-card">
                <div class="metric-value">{data['chatbot']['total_messages']}</div>
                <div class="metric-label">Mensagens (24h)</div>
            </div>
            <div class="metric-card">
                <div class="metric-value {self._get_status_class(data['chatbot']['success_rate'], 90, 70)}">{data['chatbot']['success_rate']}%</div>
                <div class="metric-label">Taxa de Sucesso</div>
            </div>
            <div class="metric-card">
                <div class="metric-value {self._get_status_class(100-data['system']['cpu_avg'], 70, 50)}">{data['system']['cpu_avg']}%</div>
                <div class="metric-label">CPU Médio</div>
            </div>
            <div class="metric-card">
                <div class="metric-value {self._get_status_class(100-data['system']['memory_avg'], 70, 50)}">{data['system']['memory_avg']}%</div>
                <div class="metric-label">Memória Média</div>
            </div>
        </div>
        
        <div class="charts">
            <div class="chart">
                <h3>🎯 Top Intenções Detectadas</h3>
                {self._generate_intent_list(data['top_intents'])}
            </div>
            <div class="chart">
                <h3>⚠️ Erros Recentes</h3>
                {self._generate_error_list(data['recent_errors'])}
            </div>
        </div>
        
        <div class="chart" style="margin-top: 20px;">
            <h3>📊 Resumo de Performance</h3>
            <div class="list-item">Tempo médio de processamento: <strong>{data['chatbot']['avg_processing_time']}ms</strong></div>
            <div class="list-item">Confiança média nas intenções: <strong>{data['chatbot']['avg_confidence']}</strong></div>
            <div class="list-item">Uso de disco: <strong>{data['system']['disk_avg']}%</strong></div>
            <div class="list-item">Última atualização: <strong>{data['generated_at'][:19]}</strong></div>
        </div>
    </div>
    
    <script>
        // Auto-refresh a cada 30 segundos
        setTimeout(() => location.reload(), 30000);
    </script>
</body>
</html>
        '''
        
        return html
    
    def _get_status_class(self, value: float, good_threshold: float, warning_threshold: float) -> str:
        """Determina classe CSS baseada no valor"""
        if value >= good_threshold:
            return "status-ok"
        elif value >= warning_threshold:
            return "status-warning"
        else:
            return "status-error"
    
    def _generate_intent_list(self, intents: List) -> str:
        """Gera lista HTML de intenções"""
        if not intents:
            return "<p>Nenhuma intenção detectada nas últimas 24h</p>"
        
        html = ""
        for intent_data in intents:
            html += f'<div class="list-item">{intent_data["intent"]}: <strong>{intent_data["count"]}</strong></div>'
        
        return html
    
    def _generate_error_list(self, errors: List) -> str:
        """Gera lista HTML de erros"""
        if not errors:
            return '<p class="status-ok">Nenhum erro nas últimas 24h ✅</p>'
        
        html = ""
        for error_data in errors:
            html += f'<div class="list-item status-error">{error_data["type"]}: <strong>{error_data["count"]}</strong></div>'
        
        return html
```

## **5.2. Sistema de Alertas**

### **Arquivo: `src/alert_system.py`**

```python
import logging
import smtplib
import json
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from datetime import datetime
from typing import Dict, List, Optional

class AlertSystem:
    def __init__(self, config_path="config/alert_config.json"):
        """
        Sistema de alertas para monitoramento
        """
        self.logger = logging.getLogger(__name__)
        self.config = self._load_config(config_path)
        self.alert_history = []
    
    def _load_config(self, config_path):
        """Carrega configurações de alerta"""
        try:
            with open(config_path, 'r', encoding='utf-8') as f:
                return json.load(f)
        except FileNotFoundError:
            return self._get_default_config()
    
    def _get_default_config(self):
        """Configuração padrão de alertas"""
        return {
            "email": {
                "enabled": False,
                "smtp_server": "smtp.gmail.com",
                "smtp_port": 587,
                "username": "",
                "password": "",
                "recipients": []
            },
            "thresholds": {
                "cpu_usage": 80,
                "memory_usage": 85,
                "error_rate": 10,
                "response_time": 5000
            },
            "cooldown_minutes": 30
        }
    
    def check_system_health(self, metrics: Dict) -> List[Dict]:
        """
        Verifica saúde do sistema e gera alertas
        
        Parâmetros:
            metrics: Métricas do sistema
            
        Retorna:
            List[Dict]: Lista de alertas gerados
        """
        alerts = []
        thresholds = self.config.get("thresholds", {})
        
        # Verificar CPU
        cpu_usage = metrics.get("system", {}).get("cpu_avg", 0)
        if cpu_usage > thresholds.get("cpu_usage", 80):
            alerts.append({
                "type": "cpu_high",
                "severity": "warning",
                "message": f"Alto uso de CPU: {cpu_usage}%",
                "value": cpu_usage,
                "threshold": thresholds.get("cpu_usage", 80)
            })
        
        # Verificar memória
        memory_usage = metrics.get("system", {}).get("memory_avg", 0)
        if memory_usage > thresholds.get("memory_usage", 85):
            alerts.append({
                "type": "memory_high",
                "severity": "warning",
                "message": f"Alto uso de memória: {memory_usage}%",
                "value": memory_usage,
                "threshold": thresholds.get("memory_usage", 85)
            })
        
        # Verificar taxa de sucesso
        success_rate = metrics.get("chatbot", {}).get("success_rate", 100)
        error_rate = 100 - success_rate
        if error_rate > thresholds.get("error_rate", 10):
            alerts.append({
                "type": "error_rate_high",
                "severity": "critical",
                "message": f"Alta taxa de erro: {error_rate}%",
                "value": error_rate,
                "threshold": thresholds.get("error_rate", 10)
            })
        
        # Verificar tempo de resposta
        response_time = metrics.get("chatbot", {}).get("avg_processing_time", 0)
        if response_time > thresholds.get("response_time", 5000):
            alerts.append({
                "type": "response_time_high",
                "severity": "warning",
                "message": f"Tempo de resposta alto: {response_time}ms",
                "value": response_time,
                "threshold": thresholds.get("response_time", 5000)
            })
        
        # Processar alertas
        for alert in alerts:
            self._process_alert(alert)
        
        return alerts
    
    def _process_alert(self, alert: Dict):
        """Processa um alerta"""
        # Verificar se alerta já foi enviado recentemente (cooldown)
        if self._is_in_cooldown(alert["type"]):
            return
        
        # Adicionar timestamp
        alert["timestamp"] = datetime.now().isoformat()
        
        # Log do alerta
        self.logger.warning(f"ALERTA [{alert['severity'].upper()}]: {alert['message']}")
        
        # Enviar por email se configurado
        if self.config.get("email", {}).get("enabled", False):
            self._send_email_alert(alert)
        
        # Adicionar ao histórico
        self.alert_history.append(alert)
        
        # Manter apenas os últimos 100 alertas
        if len(self.alert_history) > 100:
            self.alert_history = self.alert_history[-100:]
    
    def _is_in_cooldown(self, alert_type: str) -> bool:
        """Verifica se alerta está em período de cooldown"""
        cooldown_minutes = self.config.get("cooldown_minutes", 30)
        cutoff_time = datetime.now().timestamp() - (cooldown_minutes * 60)
        
        for alert in reversed(self.alert_history):
            alert_time = datetime.fromisoformat(alert["timestamp"]).timestamp()
            if alert_time < cutoff_time:
                break
            
            if alert["type"] == alert_type:
                return True
        
        return False
    
    def _send_email_alert(self, alert: Dict):
        """Envia alerta por email"""
        try:
            email_config = self.config.get("email", {})
            
            msg = MIMEMultipart()
            msg['From'] = email_config.get("username", "")
            msg['To'] = ", ".join(email_config.get("recipients", []))
            msg['Subject'] = f"[Chatbot Alert] {alert['severity'].upper()}: {alert['type']}"
            
            body = f"""
Alerta do Sistema de Chatbot - Novo Atacarejo

Tipo: {alert['type']}
Severidade: {alert['severity']}
Mensagem: {alert['message']}
Valor atual: {alert.get('value', 'N/A')}
Limite configurado: {alert.get('threshold', 'N/A')}
Timestamp: {alert['timestamp']}

Por favor, verifique o sistema o mais breve possível.

---
Sistema de Monitoramento Automático
Novo Atacarejo Chatbot
            """
            
            msg.attach(MIMEText(body, 'plain'))
            
            server = smtplib.SMTP(email_config.get("smtp_server", ""), email_config.get("smtp_port", 587))
            server.starttls()
            server.login(email_config.get("username", ""), email_config.get("password", ""))
            
            text = msg.as_string()
            server.sendmail(email_config.get("username", ""), email_config.get("recipients", []), text)
            server.quit()
            
            self.logger.info("Alerta enviado por email com sucesso")
            
        except Exception as e:
            self.logger.error(f"Erro ao enviar email de alerta: {e}")
    
    def get_alert_summary(self, hours: int = 24) -> Dict:
        """Obtém resumo de alertas"""
        cutoff_time = datetime.now().timestamp() - (hours * 3600)
        
        recent_alerts = [
            alert for alert in self.alert_history
            if datetime.fromisoformat(alert["timestamp"]).timestamp() > cutoff_time
        ]
        
        summary = {
            "total_alerts": len(recent_alerts),
            "critical_alerts": len([a for a in recent_alerts if a["severity"] == "critical"]),
            "warning_alerts": len([a for a in recent_alerts if a["severity"] == "warning"]),
            "alert_types": {}
        }
        
        for alert in recent_alerts:
            alert_type = alert["type"]
            if alert_type not in summary["alert_types"]:
                summary["alert_types"][alert_type] = 0
            summary["alert_types"][alert_type] += 1
        
        return summary
```

## **5.3. Sistema de Backup e Recuperação**

### **Arquivo: `src/backup_system.py`**

```python
import os
import shutil
import gzip
import json
import sqlite3
from datetime import datetime
from typing import Dict, List
import logging

class BackupSystem:
    def __init__(self, backup_dir="backups"):
        """
        Sistema de backup e recuperação
        """
        self.logger = logging.getLogger(__name__)
        self.backup_dir = backup_dir
        os.makedirs(backup_dir, exist_ok=True)
    
    def create_full_backup(self) -> str:
        """
        Cria backup completo do sistema
        
        Retorna:
            str: Caminho do arquivo de backup
        """
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_name = f"chatbot_backup_{timestamp}"
        backup_path = os.path.join(self.backup_dir, backup_name)
        
        self.logger.info(f"Iniciando backup completo: {backup_name}")
        
        # Criar estrutura do backup
        os.makedirs(backup_path, exist_ok=True)
        
        # Backup dos arquivos de configuração
        config_backup = os.path.join(backup_path, "config")
        if os.path.exists("config"):
            shutil.copytree("config", config_backup)
            self.logger.info("Backup de configurações concluído")
        
        # Backup dos dados
        data_backup = os.path.join(backup_path, "data")
        if os.path.exists("data"):
            shutil.copytree("data", data_backup)
            self.logger.info("Backup de dados concluído")
        
        # Backup dos logs
        logs_backup = os.path.join(backup_path, "logs")
        if os.path.exists("logs"):
            shutil.copytree("logs", logs_backup)
            self.logger.info("Backup de logs concluído")
        
        # Backup do código fonte
        src_backup = os.path.join(backup_path, "src")
        if os.path.exists("src"):
            shutil.copytree("src", src_backup)
            self.logger.info("Backup do código fonte concluído")
        
        # Criar metadados do backup
        metadata = {
            "backup_date": datetime.now().isoformat(),
            "backup_type": "full",
            "version": "2.0.0",
            "files_included": ["config", "data", "logs", "src"],
            "size_mb": self._get_directory_size(backup_path) / (1024 * 1024)
        }
        
        with open(os.path.join(backup_path, "backup_metadata.json"), "w") as f:
            json.dump(metadata, f, indent=2)
        
        # Comprimir backup
        compressed_path = f"{backup_path}.tar.gz"
        shutil.make_archive(backup_path, 'gztar', backup_path)
        
        # Remover diretório não comprimido
        shutil.rmtree(backup_path)
        
        self.logger.info(f"Backup completo criado: {compressed_path}")
        return compressed_path
    
    def create_database_backup(self) -> str:
        """
        Cria backup apenas dos bancos de dados
        
        Retorna:
            str: Caminho do backup do banco
        """
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_name = f"database_backup_{timestamp}.sql"
        backup_path = os.path.join(self.backup_dir, backup_name)
        
        self.logger.info("Iniciando backup do banco de dados")
        
        databases = []
        
        # Encontrar todos os arquivos .db
        for root, dirs, files in os.walk("."):
            for file in files:
                if file.endswith(".db"):
                    databases.append(os.path.join(root, file))
        
        # Criar backup SQL
        with open(backup_path, 'w') as backup_file:
            backup_file.write(f"-- Backup do banco de dados - {datetime.now().isoformat()}\n\n")
            
            for db_path in databases:
                backup_file.write(f"-- Backup de: {db_path}\n")
                
                try:
                    conn = sqlite3.connect(db_path)
                    
                    # Obter estrutura das tabelas
                    cursor = conn.cursor()
                    cursor.execute("SELECT sql FROM sqlite_master WHERE type='table';")
                    tables = cursor.fetchall()
                    
                    for table_sql in tables:
                        if table_sql[0]:
                            backup_file.write(f"{table_sql[0]};\n")
                    
                    # Obter dados das tabelas
                    cursor.execute("SELECT name FROM sqlite_master WHERE type='table';")
                    table_names = cursor.fetchall()
                    
                    for table_name in table_names:
                        table = table_name[0]
                        cursor.execute(f"SELECT * FROM {table}")
                        rows = cursor.fetchall()
                        
                        if rows:
                            # Obter nomes das colunas
                            cursor.execute(f"PRAGMA table_info({table})")
                            columns = [col[1] for col in cursor.fetchall()]
                            
                            backup_file.write(f"\\n-- Dados da tabela {table}\\n")
                            for row in rows:
                                values = []
                                for value in row:
                                    if value is None:
                                        values.append("NULL")
                                    elif isinstance(value, str):
                                        values.append(f"'{value.replace(chr(39), chr(39)+chr(39))}'")
                                    else:
                                        values.append(str(value))
                                
                                backup_file.write(f"INSERT INTO {table} VALUES ({', '.join(values)});\\n")
                    
                    conn.close()
                    
                except Exception as e:
                    self.logger.error(f"Erro ao fazer backup do banco {db_path}: {e}")
                    backup_file.write(f"-- ERRO no backup de {db_path}: {e}\\n")
                
                backup_file.write("\\n\\n")
        
        self.logger.info(f"Backup do banco de dados criado: {backup_path}")
        return backup_path
    
    def restore_backup(self, backup_path: str) -> bool:
        """
        Restaura backup do sistema
        
        Parâmetros:
            backup_path: Caminho do arquivo de backup
            
        Retorna:
            bool: True se restaurado com sucesso
        """
        try:
            self.logger.info(f"Iniciando restauração do backup: {backup_path}")
            
            # Criar backup de segurança antes da restauração
            safety_backup = self.create_full_backup()
            self.logger.info(f"Backup de segurança criado: {safety_backup}")
            
            # Extrair backup
            extract_dir = os.path.join(self.backup_dir, "temp_restore")
            shutil.unpack_archive(backup_path, extract_dir)
            
            # Verificar metadados
            metadata_path = os.path.join(extract_dir, "backup_metadata.json")
            if os.path.exists(metadata_path):
                with open(metadata_path, 'r') as f:
                    metadata = json.load(f)
                    self.logger.info(f"Restaurando backup de {metadata['backup_date']}")
            
            # Restaurar arquivos
            for item in os.listdir(extract_dir):
                if item == "backup_metadata.json":
                    continue
                
                source = os.path.join(extract_dir, item)
                target = item
                
                if os.path.exists(target):
                    if os.path.isdir(target):
                        shutil.rmtree(target)
                    else:
                        os.remove(target)
                
                if os.path.isdir(source):
                    shutil.copytree(source, target)
                else:
                    shutil.copy2(source, target)
                
                self.logger.info(f"Restaurado: {item}")
            
            # Limpar arquivos temporários
            shutil.rmtree(extract_dir)
            
            self.logger.info("Restauração concluída com sucesso")
            return True
            
        except Exception as e:
            self.logger.error(f"Erro durante restauração: {e}")
            return False
    
    def cleanup_old_backups(self, keep_days: int = 30):
        """
        Remove backups antigos
        
        Parâmetros:
            keep_days: Número de dias para manter backups
        """
        cutoff_time = datetime.now().timestamp() - (keep_days * 24 * 3600)
        removed_count = 0
        
        for filename in os.listdir(self.backup_dir):
            file_path = os.path.join(self.backup_dir, filename)
            
            if os.path.isfile(file_path):
                file_time = os.path.getmtime(file_path)
                
                if file_time < cutoff_time:
                    os.remove(file_path)
                    removed_count += 1
                    self.logger.info(f"Backup antigo removido: {filename}")
        
        self.logger.info(f"Limpeza concluída: {removed_count} backups removidos")
    
    def _get_directory_size(self, directory: str) -> int:
        """Calcula tamanho total de um diretório"""
        total_size = 0
        for dirpath, dirnames, filenames in os.walk(directory):
            for filename in filenames:
                file_path = os.path.join(dirpath, filename)
                total_size += os.path.getsize(file_path)
        return total_size
    
    def get_backup_list(self) -> List[Dict]:
        """
        Obtém lista de backups disponíveis
        
        Retorna:
            List[Dict]: Lista de backups com metadados
        """
        backups = []
        
        for filename in os.listdir(self.backup_dir):
            file_path = os.path.join(self.backup_dir, filename)
            
            if os.path.isfile(file_path) and (filename.endswith('.tar.gz') or filename.endswith('.sql')):
                stat = os.stat(file_path)
                
                backup_info = {
                    "filename": filename,
                    "path": file_path,
                    "size_mb": round(stat.st_size / (1024 * 1024), 2),
                    "created_date": datetime.fromtimestamp(stat.st_mtime).isoformat(),
                    "type": "database" if filename.endswith('.sql') else "full"
                }
                
                backups.append(backup_info)
        
        # Ordenar por data de criação (mais recente primeiro)
        backups.sort(key=lambda x: x['created_date'], reverse=True)
        
        return backups
```

## **5.4. Manutenção Automática**

### **Arquivo: `src/maintenance_system.py`**

```python
import schedule
import time
import threading
import logging
from datetime import datetime
from .monitoring_dashboard import MonitoringDashboard
from .alert_system import AlertSystem
from .backup_system import BackupSystem

class MaintenanceSystem:
    def __init__(self):
        """
        Sistema de manutenção automática
        """
        self.logger = logging.getLogger(__name__)
        self.monitoring = MonitoringDashboard()
        self.alerts = AlertSystem()
        self.backup = BackupSystem()
        self.running = False
        self.thread = None
    
    def start_maintenance_scheduler(self):
        """Inicia agendamento de tarefas de manutenção"""
        if self.running:
            self.logger.warning("Sistema de manutenção já está rodando")
            return
        
        self.logger.info("Iniciando sistema de manutenção automática")
        
        # Agendar tarefas
        schedule.every(5).minutes.do(self._collect_metrics)
        schedule.every(15).minutes.do(self._check_alerts)
        schedule.every().day.at("02:00").do(self._daily_backup)
        schedule.every().week.do(self._weekly_cleanup)
        schedule.every().hour.do(self._health_check)
        
        self.running = True
        self.thread = threading.Thread(target=self._run_scheduler, daemon=True)
        self.thread.start()
        
        self.logger.info("Sistema de manutenção iniciado com sucesso")
    
    def stop_maintenance_scheduler(self):
        """Para o sistema de manutenção"""
        self.running = False
        schedule.clear()
        
        if self.thread:
            self.thread.join(timeout=5)
        
        self.logger.info("Sistema de manutenção parado")
    
    def _run_scheduler(self):
        """Executa o agendador em thread separada"""
        while self.running:
            try:
                schedule.run_pending()
                time.sleep(60)  # Verificar a cada minuto
            except Exception as e:
                self.logger.error(f"Erro no agendador de manutenção: {e}")
                time.sleep(60)
    
    def _collect_metrics(self):
        """Coleta métricas do sistema"""
        try:
            self.logger.debug("Coletando métricas do sistema")
            self.monitoring.log_system_metrics()
        except Exception as e:
            self.logger.error(f"Erro ao coletar métricas: {e}")
    
    def _check_alerts(self):
        """Verifica e processa alertas"""
        try:
            self.logger.debug("Verificando alertas")
            
            # Obter métricas para análise
            dashboard_data = self.monitoring.get_dashboard_data()
            
            # Verificar saúde e gerar alertas
            alerts = self.alerts.check_system_health(dashboard_data)
            
            if alerts:
                self.logger.info(f"Gerados {len(alerts)} alertas")
            
        except Exception as e:
            self.logger.error(f"Erro ao verificar alertas: {e}")
    
    def _daily_backup(self):
        """Executa backup diário"""
        try:
            self.logger.info("Iniciando backup diário")
            
            # Backup completo
            backup_path = self.backup.create_full_backup()
            
            # Backup do banco de dados
            db_backup_path = self.backup.create_database_backup()
            
            self.logger.info(f"Backup diário concluído: {backup_path}, {db_backup_path}")
            
        except Exception as e:
            self.logger.error(f"Erro no backup diário: {e}")
    
    def _weekly_cleanup(self):
        """Executa limpeza semanal"""
        try:
            self.logger.info("Iniciando limpeza semanal")
            
            # Limpar backups antigos (manter 30 dias)
            self.backup.cleanup_old_backups(keep_days=30)
            
            # Limpar logs antigos
            self._cleanup_old_logs(keep_days=14)
            
            # Compactar banco de dados
            self._optimize_databases()
            
            self.logger.info("Limpeza semanal concluída")
            
        except Exception as e:
            self.logger.error(f"Erro na limpeza semanal: {e}")
    
    def _health_check(self):
        """Executa verificação de saúde"""
        try:
            self.logger.debug("Executando verificação de saúde")
            
            # Verificar se todos os componentes estão funcionando
            components = {
                "monitoring": self._test_monitoring(),
                "alerts": self._test_alerts(),
                "backup": self._test_backup(),
                "disk_space": self._check_disk_space()
            }
            
            # Log dos resultados
            failed_components = [name for name, status in components.items() if not status]
            
            if failed_components:
                self.logger.warning(f"Componentes com falha: {failed_components}")
            else:
                self.logger.debug("Todos os componentes estão funcionando")
            
        except Exception as e:
            self.logger.error(f"Erro na verificação de saúde: {e}")
    
    def _cleanup_old_logs(self, keep_days: int = 14):
        """Limpa logs antigos"""
        import os
        import glob
        
        cutoff_time = datetime.now().timestamp() - (keep_days * 24 * 3600)
        
        log_files = glob.glob("logs/*.log") + glob.glob("logs/*.log.*")
        removed_count = 0
        
        for log_file in log_files:
            try:
                if os.path.getmtime(log_file) < cutoff_time:
                    os.remove(log_file)
                    removed_count += 1
            except Exception as e:
                self.logger.error(f"Erro ao remover log {log_file}: {e}")
        
        if removed_count > 0:
            self.logger.info(f"Removidos {removed_count} arquivos de log antigos")
    
    def _optimize_databases(self):
        """Otimiza bancos de dados SQLite"""
        import sqlite3
        import glob
        
        db_files = glob.glob("data/*.db")
        
        for db_file in db_files:
            try:
                conn = sqlite3.connect(db_file)
                conn.execute("VACUUM")
                conn.execute("ANALYZE")
                conn.close()
                self.logger.debug(f"Banco otimizado: {db_file}")
            except Exception as e:
                self.logger.error(f"Erro ao otimizar banco {db_file}: {e}")
    
    def _test_monitoring(self) -> bool:
        """Testa sistema de monitoramento"""
        try:
            self.monitoring.get_dashboard_data()
            return True
        except:
            return False
    
    def _test_alerts(self) -> bool:
        """Testa sistema de alertas"""
        try:
            self.alerts.get_alert_summary()
            return True
        except:
            return False
    
    def _test_backup(self) -> bool:
        """Testa sistema de backup"""
        try:
            self.backup.get_backup_list()
            return True
        except:
            return False
    
    def _check_disk_space(self) -> bool:
        """Verifica espaço em disco"""
        import shutil
        
        try:
            total, used, free = shutil.disk_usage("/")
            free_percent = (free / total) * 100
            
            # Alertar se menos de 10% livre
            if free_percent < 10:
                self.logger.warning(f"Pouco espaço em disco: {free_percent:.1f}% livre")
                return False
            
            return True
        except:
            return False
    
    def get_maintenance_status(self) -> dict:
        """Obtém status do sistema de manutenção"""
        return {
            "running": self.running,
            "scheduled_jobs": len(schedule.jobs),
            "next_run": str(schedule.next_run()) if schedule.jobs else None,
            "last_metrics_collection": datetime.now().isoformat(),
            "maintenance_thread_alive": self.thread.is_alive() if self.thread else False
        }
```

## **5.5. Aplicação Final Integrada**

### **Arquivo atualizado: `app.py`**

```python
from fastapi import FastAPI, Request, HTTPException, Query
from fastapi.responses import HTMLResponse, PlainTextResponse
import logging
import json
import uvicorn
import os
from datetime import datetime
from src.smart_chatbot import SmartChatbot
from src.monitoring_dashboard import MonitoringDashboard
from src.alert_system import AlertSystem
from src.backup_system import BackupSystem
from src.maintenance_system import MaintenanceSystem

# Configurar logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('logs/chatbot.log'),
        logging.StreamHandler()
    ]
)

# Inicializar aplicação
app = FastAPI(title="WhatsApp LLaMA Chatbot - Produção", version="3.0.0")

# Instanciar sistemas
smart_chatbot = SmartChatbot()
monitoring = MonitoringDashboard()
alerts = AlertSystem()
backup_system = BackupSystem()
maintenance = MaintenanceSystem()

@app.on_event("startup")
async def startup_event():
    """Eventos de inicialização"""
    logging.info("Iniciando sistemas de produção...")
    
    # Iniciar sistema de manutenção automática
    maintenance.start_maintenance_scheduler()
    
    logging.info("Sistemas de produção iniciados com sucesso")

@app.on_event("shutdown")
async def shutdown_event():
    """Eventos de finalização"""
    logging.info("Finalizando sistemas...")
    
    # Parar sistema de manutenção
    maintenance.stop_maintenance_scheduler()
    
    # Criar backup final
    try:
        backup_path = backup_system.create_database_backup()
        logging.info(f"Backup final criado: {backup_path}")
    except Exception as e:
        logging.error(f"Erro ao criar backup final: {e}")
    
    logging.info("Sistemas finalizados")

@app.get("/")
def root():
    """Endpoint raiz"""
    return {
        "message": "WhatsApp LLaMA Chatbot - Sistema de Produção",
        "version": "3.0.0",
        "status": "operational",
        "features": [
            "Chatbot inteligente",
            "Monitoramento em tempo real",
            "Sistema de alertas",
            "Backup automático",
            "Manutenção automática"
        ],
        "endpoints": {
            "dashboard": "/dashboard",
            "health": "/health",
            "backup": "/admin/backup",
            "stats": "/stats"
        }
    }

@app.get("/webhook")
def verify_webhook(
    hub_mode: str = Query(alias="hub.mode"),
    hub_verify_token: str = Query(alias="hub.verify_token"), 
    hub_challenge: str = Query(alias="hub.challenge")
):
    """Verificação do webhook do WhatsApp"""
    try:
        VERIFY_TOKEN = "meu_token_webhook_123"
        
        if hub_mode == "subscribe" and hub_verify_token == VERIFY_TOKEN:
            logging.info("Webhook verificado com sucesso")
            return PlainTextResponse(hub_challenge)
        else:
            logging.error("Token de verificação inválido")
            raise HTTPException(status_code=403, detail="Proibido")
            
    except Exception as e:
        logging.error(f"Erro na verificação do webhook: {e}")
        raise HTTPException(status_code=500, detail="Erro Interno do Servidor")

@app.post("/webhook")
async def receive_message(request: Request):
    """Recebe mensagens do WhatsApp via webhook"""
    start_time = datetime.now()
    
    try:
        webhook_data = await request.json()
        logging.info("Webhook recebido")
        
        # Processar com chatbot inteligente
        success = smart_chatbot.process_message(webhook_data)
        
        # Calcular tempo de processamento
        processing_time = (datetime.now() - start_time).total_seconds() * 1000
        
        # Log do evento para monitoramento
        event_data = {
            "event_type": "message_received",
            "success": success,
            "processing_time_ms": processing_time,
            "timestamp": start_time.isoformat()
        }
        
        monitoring.log_chatbot_event(event_data)
        
        if success:
            return {"status": "success", "processing_time_ms": processing_time}
        else:
            return {"status": "error", "processing_time_ms": processing_time}
            
    except Exception as e:
        # Log do erro
        error_data = {
            "error_type": "webhook_processing",
            "error_message": str(e),
            "request_data": await request.json() if hasattr(request, 'json') else {}
        }
        
        monitoring.log_error(error_data)
        logging.error(f"Erro ao processar webhook: {e}")
        raise HTTPException(status_code=500, detail="Erro Interno do Servidor")

@app.get("/dashboard", response_class=HTMLResponse)
def get_dashboard():
    """Dashboard de monitoramento"""
    try:
        return monitoring.generate_html_dashboard()
    except Exception as e:
        logging.error(f"Erro ao gerar dashboard: {e}")
        return HTMLResponse("<h1>Erro ao carregar dashboard</h1>", status_code=500)

@app.get("/health")
def health_check():
    """Endpoint de verificação de saúde completo"""
    try:
        # Estatísticas do chatbot
        chatbot_stats = smart_chatbot.get_conversation_stats()
        
        # Dados do dashboard
        dashboard_data = monitoring.get_dashboard_data()
        
        # Status de manutenção
        maintenance_status = maintenance.get_maintenance_status()
        
        # Verificar alertas recentes
        alert_summary = alerts.get_alert_summary(hours=1)
        
        # Lista de backups
        backup_list = backup_system.get_backup_list()
        
        health_status = {
            "status": "healthy",
            "timestamp": datetime.now().isoformat(),
            "components": {
                "api": True,
                "chatbot": True,
                "monitoring": True,
                "alerts": True,
                "backup": True,
                "maintenance": maintenance_status["running"]
            },
            "metrics": {
                "chatbot": chatbot_stats,
                "system": dashboard_data["system"],
                "performance": dashboard_data["chatbot"]
            },
            "alerts": alert_summary,
            "maintenance": maintenance_status,
            "backups": {
                "total_backups": len(backup_list),
                "latest_backup": backup_list[0]["created_date"] if backup_list else None
            }
        }
        
        # Determinar status geral
        if alert_summary["critical_alerts"] > 0:
            health_status["status"] = "critical"
        elif alert_summary["warning_alerts"] > 0:
            health_status["status"] = "warning"
        
        return health_status
        
    except Exception as e:
        logging.error(f"Erro no health check: {e}")
        return {
            "status": "unhealthy",
            "error": str(e),
            "timestamp": datetime.now().isoformat()
        }

@app.get("/stats")
def get_detailed_stats():
    """Estatísticas detalhadas do sistema"""
    try:
        return {
            "chatbot_stats": smart_chatbot.get_conversation_stats(),
            "dashboard_data": monitoring.get_dashboard_data(),
            "alert_summary": alerts.get_alert_summary(hours=24),
            "backup_list": backup_system.get_backup_list()[:5],  # Últimos 5 backups
            "maintenance_status": maintenance.get_maintenance_status()
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/admin/backup")
def create_manual_backup():
    """Cria backup manual (endpoint administrativo)"""
    try:
        backup_path = backup_system.create_full_backup()
        return {
            "status": "success",
            "backup_path": backup_path,
            "timestamp": datetime.now().isoformat()
        }
    except Exception as e:
        logging.error(f"Erro ao criar backup manual: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/test-message")
async def test_message(request: Request):
    """Endpoint para testar processamento de mensagens"""
    try:
        data = await request.json()
        
        test_webhook = {
            "entry": [{
                "changes": [{
                    "value": {
                        "messages": [{
                            "from": data.get("from", "5511999999999"),
                            "text": {"body": data.get("message", "Olá!")},
                            "type": "text"
                        }]
                    }
                }]
            }]
        }
        
        success = smart_chatbot.process_message(test_webhook)
        
        return {
            "status": "success" if success else "error",
            "message": "Teste processado",
            "features_active": [
                "Intent Classification",
                "Knowledge Base",
                "Response Caching",
                "Context Management"
            ]
        }
        
    except Exception as e:
        logging.error(f"Erro no teste: {e}")
        raise HTTPException(status_code=500, detail="Erro Interno do Servidor")

if __name__ == "__main__":
    # Criar diretórios necessários
    os.makedirs("logs", exist_ok=True)
    os.makedirs("data", exist_ok=True)
    os.makedirs("config", exist_ok=True)
    os.makedirs("backups", exist_ok=True)
    
    # Executar servidor
    uvicorn.run(
        "app:app",
        host="0.0.0.0",
        port=5000,
        reload=False,  # Disabled em produção
        log_level="info"
    )
```

## **5.6. Documentação de Operação**

### **Arquivo: `OPERATIONAL_GUIDE.md`**

```markdown
# Guia Operacional - Chatbot WhatsApp LLaMA

## Monitoramento Diário

### Dashboard Principal
Acesse: `http://seu-servidor:5000/dashboard`

**Métricas importantes para monitorar:**
- Taxa de sucesso > 90%
- Tempo de resposta < 3000ms
- CPU < 80%
- Memória < 85%

### Health Check
Endpoint: `GET /health`

**Status possíveis:**
- `healthy`: Sistema funcionando normalmente
- `warning`: Alguns alertas ativos
- `critical`: Problemas sérios detectados
- `unhealthy`: Sistema com falhas

## Manutenção de Rotina

### Backups
- **Automático**: Backup diário às 02:00
- **Manual**: `POST /admin/backup`
- **Localização**: Diretório `backups/`

### Limpeza Automática
- Logs antigos (>14 dias): Removidos automaticamente
- Backups antigos (>30 dias): Removidos automaticamente
- Cache de respostas: Limitado a 100 entradas

### Otimização Semanal
- Compactação de bancos de dados
- Análise de performance
- Verificação de integridade

## Resolução de Problemas

### Alto Uso de CPU/Memória
1. Verificar logs: `tail -f logs/chatbot.log`
2. Reiniciar serviço se necessário
3. Verificar se há processo pesado rodando

### Falhas de Resposta
1. Verificar status do LLaMA
2. Testar endpoint: `POST /test-message`
3. Verificar conectividade com WhatsApp

### Alertas Críticos
1. Verificar dashboard imediatamente
2. Analisar logs de erro
3. Executar backup se necessário
4. Contatar suporte técnico

## Comandos Úteis

### Logs
```bash
# Monitorar logs em tempo real
tail -f logs/chatbot.log

# Filtrar apenas erros
grep "ERROR" logs/chatbot.log

# Logs das últimas 24h
find logs/ -name "*.log" -mtime -1
```

### Backup e Restore
```bash
# Backup manual
curl -X POST http://localhost:5000/admin/backup

# Listar backups
ls -la backups/

# Restaurar backup (exemplo)
python -c "from src.backup_system import BackupSystem; bs = BackupSystem(); bs.restore_backup('backups/chatbot_backup_20241201_120000.tar.gz')"
```

### Monitoramento
```bash
# Status do sistema
curl http://localhost:5000/health | jq

# Estatísticas detalhadas
curl http://localhost:5000/stats | jq

# Testar chatbot
curl -X POST http://localhost:5000/test-message \
  -H "Content-Type: application/json" \
  -d '{"message": "Olá, como funciona?"}'
```

## Contatos de Emergência

- **Administrador do Sistema**: [seu-email@empresa.com]
- **Suporte Técnico**: [suporte@empresa.com]
- **WhatsApp Business Support**: [Conforme sua configuração]

## Procedimentos de Emergência

### Sistema Inoperante
1. Verificar logs de erro
2. Tentar reinicialização
3. Restaurar backup mais recente
4. Contatar suporte se necessário

### Perda de Dados
1. Parar sistema imediatamente
2. Verificar último backup válido
3. Executar procedimento de restauração
4. Validar integridade dos dados

### Comprometimento de Segurança
1. Isolar sistema da rede
2. Analisar logs de acesso
3. Trocar credenciais
4. Investigar extensão do problema
```

---

**✅ Parabéns!** Seu sistema de chatbot está agora completamente operacional com monitoramento e manutenção automatizados!

**🎯 Sistemas implementados:**
- ✅ Dashboard de monitoramento em tempo real
- ✅ Sistema de alertas automáticos
- ✅ Backup e recuperação automatizados
- ✅ Manutenção programada
- ✅ Health checks detalhados
- ✅ Logs estruturados
- ✅ Documentação operacional

**🚀 Para iniciar em produção:**
```bash
# Executar setup completo
python setup_personalization.py

# Iniciar sistema
python app.py

# Acessar dashboard
http://localhost:5000/dashboard
```

**🔧 O sistema agora inclui:**
- Monitoramento 24/7
- Alertas por email
- Backup diário automático
- Limpeza automática de arquivos
- Otimização de performance
- Recuperação de desastres
- Documentação completa

Seu chatbot está pronto para produção com máxima confiabilidade e observabilidade!
