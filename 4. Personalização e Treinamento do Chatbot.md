# **4. Personalização e Treinamento do Chatbot**

Agora que temos a integração funcionando, vamos personalizar o chatbot para atender às necessidades específicas da empresa Novo Atacarejo. Esta seção cobrirá personalização de respostas, criação de conhecimento específico, treinamento com dados customizados e otimização de performance.

## **4.1. Personalização de Prompts e Personalidade**

### **Definindo a Personalidade do Chatbot**

Vamos criar uma personalidade consistente e profissional para o assistente virtual:

#### **Arquivo: `config/personality_config.json`**

```json
{
  "company_info": {
    "name": "Novo Atacarejo",
    "business_type": "Rede de atacado e varejo",
    "values": ["qualidade", "preço justo", "atendimento excelente"],
    "tone": "profissional, amigável e prestativo"
  },
  "chatbot_personality": {
    "name": "Assistente Virtual Novo Atacarejo",
    "greeting_style": "cordial e profissional",
    "response_style": "claro, objetivo e útil",
    "fallback_behavior": "sempre oferecer alternativas de ajuda"
  },
  "response_templates": {
    "greeting": [
      "Olá! Sou o assistente virtual do Novo Atacarejo. Como posso ajudá-lo hoje?",
      "Bem-vindo ao Novo Atacarejo! Em que posso auxiliá-lo?",
      "Oi! É um prazer atendê-lo. Como posso ajudar?"
    ],
    "farewell": [
      "Foi um prazer ajudá-lo! Volte sempre ao Novo Atacarejo!",
      "Obrigado por escolher o Novo Atacarejo. Tenha um ótimo dia!",
      "Até logo! Estamos sempre aqui quando precisar."
    ],
    "unknown": [
      "Não tenho essa informação específica, mas posso conectá-lo com nossa equipe.",
      "Vou verificar isso para você. Enquanto isso, posso ajudar com algo mais?",
      "Ótima pergunta! Deixe-me consultar nossos especialistas sobre isso."
    ]
  }
}
```

### **Sistema de Conhecimento da Empresa**

#### **Arquivo: `data/knowledge_base.json`**

```json
{
  "produtos": {
    "categorias": [
      "Alimentos básicos (arroz, feijão, açúcar, óleo)",
      "Bebidas (refrigerantes, sucos, água, cervejas)",
      "Limpeza (detergentes, sabão, desinfetantes)",
      "Higiene pessoal (shampoo, sabonete, pasta de dente)",
      "Frios e laticínios (queijos, presunto, leite, iogurte)",
      "Frutas e verduras frescas",
      "Produtos de padaria",
      "Carnes e aves"
    ],
    "ofertas_especiais": [
      "Promoções de quarta-feira: 20% desconto em produtos de limpeza",
      "Sexta-feira da carne: descontos especiais em carnes",
      "Combo família: 15% desconto comprando acima de R$ 200"
    ]
  },
  "servicos": {
    "entrega": {
      "disponivel": true,
      "taxa": "R$ 8,00 para compras abaixo de R$ 100",
      "gratuita": "Compras acima de R$ 100",
      "prazo": "2-4 horas dentro da cidade"
    },
    "pagamento": [
      "Dinheiro", "PIX", "Cartão de débito", 
      "Cartão de crédito", "Vale alimentação"
    ],
    "horarios": {
      "segunda_sabado": "8h às 20h",
      "domingo": "8h às 14h",
      "feriados": "Consultar previamente"
    }
  },
  "localizacao": {
    "enderecos": [
      "Loja Centro: Rua Principal, 123 - Centro",
      "Loja Norte: Av. Norte, 456 - Bairro Norte", 
      "Loja Sul: Rua Sul, 789 - Bairro Sul"
    ],
    "telefone": "(11) 1234-5678",
    "whatsapp": "(11) 99999-9999"
  },
  "politicas": {
    "troca_devolucao": "7 dias para produtos não perecíveis com nota fiscal",
    "garantia": "Conforme fabricante para eletrodomésticos",
    "privacidade": "Dados protegidos conforme LGPD"
  }
}
```

## **4.2. Sistema de Classificação de Intenções**

### **Arquivo: `src/intent_classifier.py`**

```python
import json
import re
from typing import Dict, List, Tuple

class IntentClassifier:
    def __init__(self, config_path="data/knowledge_base.json"):
        """
        Classificador de intenções para o chatbot
        """
        self.knowledge_base = self._load_knowledge_base(config_path)
        self.intent_patterns = self._build_intent_patterns()
    
    def _load_knowledge_base(self, config_path):
        """Carrega base de conhecimento"""
        try:
            with open(config_path, 'r', encoding='utf-8') as f:
                return json.load(f)
        except FileNotFoundError:
            return {}
    
    def _build_intent_patterns(self):
        """Constrói padrões para classificação de intenções"""
        return {
            "greeting": {
                "keywords": ["olá", "oi", "bom dia", "boa tarde", "boa noite", "hey", "hello"],
                "patterns": [r"\b(ola|oi|bom\s+dia|boa\s+tarde|boa\s+noite)\b"]
            },
            "farewell": {
                "keywords": ["tchau", "bye", "até logo", "obrigado", "valeu", "adeus"],
                "patterns": [r"\b(tchau|bye|ate\s+logo|obrigad[oa])\b"]
            },
            "horario": {
                "keywords": ["horário", "horario", "funcionamento", "aberto", "fecha", "abre", "que horas"],
                "patterns": [r"\b(horario|funcionamento|que\s+horas|aberto|fecha)\b"]
            },
            "entrega": {
                "keywords": ["entrega", "delivery", "entregar", "levar", "frete", "envio"],
                "patterns": [r"\b(entrega|delivery|frete|envio)\b"]
            },
            "produtos": {
                "keywords": ["produto", "vende", "tem", "estoque", "disponível", "preço", "valor", "custa"],
                "patterns": [r"\b(produto|preco|valor|custa|tem|vende)\b"]
            },
            "pagamento": {
                "keywords": ["pagamento", "pagar", "cartão", "dinheiro", "pix", "débito", "crédito"],
                "patterns": [r"\b(pagamento|pagar|cartao|dinheiro|pix)\b"]
            },
            "localizacao": {
                "keywords": ["endereço", "endereco", "onde", "localização", "loja", "fica"],
                "patterns": [r"\b(endereco|onde|localizacao|loja|fica)\b"]
            },
            "ofertas": {
                "keywords": ["promoção", "desconto", "oferta", "barato", "promoções"],
                "patterns": [r"\b(promocao|desconto|oferta|barato)\b"]
            },
            "help": {
                "keywords": ["ajuda", "help", "comandos", "o que pode", "como funciona"],
                "patterns": [r"\b(ajuda|help|comandos|como\s+funciona)\b"]
            }
        }
    
    def classify_intent(self, message: str) -> Dict[str, any]:
        """
        Classifica a intenção da mensagem
        
        Parâmetros:
            message: Mensagem do usuário
            
        Retorna:
            dict: Intenção classificada com confiança
        """
        message_clean = self._clean_message(message)
        intent_scores = {}
        
        # Calcular scores para cada intenção
        for intent, config in self.intent_patterns.items():
            score = 0
            
            # Score por palavras-chave
            for keyword in config["keywords"]:
                if keyword in message_clean:
                    score += 1
            
            # Score por padrões regex
            for pattern in config["patterns"]:
                if re.search(pattern, message_clean, re.IGNORECASE):
                    score += 2  # Padrões têm peso maior
            
            if score > 0:
                intent_scores[intent] = score / (len(config["keywords"]) + len(config["patterns"]))
        
        # Retornar intenção com maior score
        if intent_scores:
            best_intent = max(intent_scores, key=intent_scores.get)
            confidence = intent_scores[best_intent]
            
            return {
                "intent": best_intent,
                "confidence": min(confidence, 1.0),  # Limitar a 1.0
                "all_scores": intent_scores
            }
        
        return {"intent": "unknown", "confidence": 0.0, "all_scores": {}}
    
    def _clean_message(self, message: str) -> str:
        """Limpa e normaliza mensagem para análise"""
        # Converter para minúsculas
        message = message.lower()
        
        # Remover acentos básicos
        replacements = {
            'ã': 'a', 'á': 'a', 'à': 'a', 'â': 'a',
            'é': 'e', 'ê': 'e', 'í': 'i', 'ó': 'o',
            'ô': 'o', 'õ': 'o', 'ú': 'u', 'ç': 'c'
        }
        
        for old, new in replacements.items():
            message = message.replace(old, new)
        
        return message
    
    def get_knowledge_response(self, intent: str, message: str = None) -> str:
        """
        Gera resposta baseada na base de conhecimento
        
        Parâmetros:
            intent: Intenção classificada
            message: Mensagem original (para contexto)
            
        Retorna:
            str: Resposta baseada no conhecimento
        """
        if intent == "horario":
            horarios = self.knowledge_base.get("servicos", {}).get("horarios", {})
            return f"""🕐 **Horários de Funcionamento:**
• Segunda a sábado: {horarios.get("segunda_sabado", "8h às 20h")}
• Domingo: {horarios.get("domingo", "8h às 14h")}
• Feriados: {horarios.get("feriados", "Consultar previamente")}"""

        elif intent == "entrega":
            entrega = self.knowledge_base.get("servicos", {}).get("entrega", {})
            return f"""🚚 **Serviço de Entrega:**
• Taxa: {entrega.get("taxa", "R$ 8,00")}
• Entrega gratuita: {entrega.get("gratuita", "Compras acima de R$ 100")}
• Prazo: {entrega.get("prazo", "2-4 horas")}"""

        elif intent == "produtos":
            categorias = self.knowledge_base.get("produtos", {}).get("categorias", [])
            return f"""🛒 **Nossos Produtos:**
{chr(10).join([f'• {cat}' for cat in categorias[:5]])}
... e muito mais! O que você procura especificamente?"""

        elif intent == "pagamento":
            pagamentos = self.knowledge_base.get("servicos", {}).get("pagamento", [])
            return f"""💳 **Formas de Pagamento:**
{chr(10).join([f'• {pag}' for pag in pagamentos])}"""

        elif intent == "localizacao":
            enderecos = self.knowledge_base.get("localizacao", {}).get("enderecos", [])
            telefone = self.knowledge_base.get("localizacao", {}).get("telefone", "")
            return f"""📍 **Nossas Lojas:**
{chr(10).join([f'• {end}' for end in enderecos])}

📞 Central: {telefone}"""

        elif intent == "ofertas":
            ofertas = self.knowledge_base.get("produtos", {}).get("ofertas_especiais", [])
            return f"""🏷️ **Ofertas Especiais:**
{chr(10).join([f'• {oferta}' for oferta in ofertas])}"""

        elif intent == "help":
            return """🤖 **Assistente Virtual - Novo Atacarejo**

Posso ajudar com:
• Consulta de horários
• Informações sobre entrega
• Localização das lojas
• Formas de pagamento
• Produtos e ofertas

Digite sua dúvida!"""

        else:
            return "Como posso ajudá-lo hoje? Estou aqui para responder suas dúvidas sobre o Novo Atacarejo!"
```

## **4.3. Chatbot Inteligente Melhorado**

### **Arquivo: `src/smart_chatbot.py`**

```python
import logging
import time
from datetime import datetime
from typing import Dict, List, Optional
from .intent_classifier import IntentClassifier

class SmartChatbot:
    def __init__(self):
        """
        Chatbot inteligente com classificação de intenções
        """
        self.logger = logging.getLogger(__name__)
        self.intent_classifier = IntentClassifier()
        self.conversations = {}  # Armazenar contexto das conversas
        self.response_cache = {}  # Cache de respostas
        
        self.logger.info("SmartChatbot inicializado com sucesso")
    
    def process_message(self, webhook_data: Dict) -> bool:
        """
        Processa mensagem recebida via webhook com IA
        
        Parâmetros:
            webhook_data: Dados do webhook
            
        Retorna:
            bool: True se processada com sucesso
        """
        try:
            # Parse da mensagem
            message_data = self._parse_webhook_message(webhook_data)
            
            if not message_data:
                self.logger.warning("Mensagem inválida ou não suportada")
                return False
            
            user_number = message_data["from"]
            user_message = message_data["text"]
            
            self.logger.info(f"Processando mensagem de {user_number}: {user_message[:50]}...")
            
            # Verificar cache de resposta
            cached_response = self._get_cached_response(user_message)
            if cached_response:
                self.logger.info("Resposta encontrada no cache")
                response = cached_response
            else:
                # Gerar nova resposta
                response = self._generate_intelligent_response(user_message, user_number)
                self._cache_response(user_message, response)
            
            # Atualizar contexto da conversa
            self._update_conversation_context(user_number, user_message, response)
            
            # Em produção, aqui enviaria via WhatsApp API
            self.logger.info(f"Resposta gerada: {response[:100]}...")
            
            return True
            
        except Exception as e:
            self.logger.error(f"Erro ao processar mensagem: {e}")
            return False
    
    def _parse_webhook_message(self, webhook_data: Dict) -> Optional[Dict]:
        """Parse de mensagem do webhook"""
        try:
            entry = webhook_data.get("entry", [])
            if not entry:
                return None
            
            changes = entry[0].get("changes", [])
            if not changes:
                return None
            
            value = changes[0].get("value", {})
            messages = value.get("messages", [])
            
            if not messages:
                return None
            
            message_data = messages[0]
            
            return {
                "from": message_data.get("from"),
                "text": message_data.get("text", {}).get("body", ""),
                "type": message_data.get("type", "text")
            }
            
        except Exception as e:
            self.logger.error(f"Erro ao processar webhook: {e}")
            return None
    
    def _generate_intelligent_response(self, message: str, user_number: str) -> str:
        """
        Gera resposta inteligente usando classificação de intenções
        
        Parâmetros:
            message: Mensagem do usuário
            user_number: Número do usuário
            
        Retorna:
            str: Resposta gerada
        """
        # Verificar comandos especiais primeiro
        special_response = self._handle_special_commands(message, user_number)
        if special_response:
            return special_response
        
        # Classificar intenção
        intent_result = self.intent_classifier.classify_intent(message)
        intent = intent_result["intent"]
        confidence = intent_result["confidence"]
        
        self.logger.info(f"Intenção detectada: {intent} (confiança: {confidence:.2f})")
        
        # Gerar resposta baseada na intenção
        if confidence >= 0.3:  # Threshold de confiança
            knowledge_response = self.intent_classifier.get_knowledge_response(intent, message)
            if knowledge_response:
                return knowledge_response
        
        # Fallback para intenções não reconhecidas
        return self._generate_fallback_response(message, intent_result)
    
    def _handle_special_commands(self, message: str, user_number: str) -> Optional[str]:
        """Processa comandos especiais"""
        message_lower = message.lower().strip()
        
        if message_lower in ["/reset", "reset", "limpar conversa"]:
            if user_number in self.conversations:
                del self.conversations[user_number]
            return "Conversa reiniciada! Como posso ajudá-lo?"
        
        if message_lower in ["/status", "status"]:
            cache_size = len(self.response_cache)
            conversations = len(self.conversations)
            
            return f"""📊 **Status do Sistema**

Cache de respostas: {cache_size}
Conversas ativas: {conversations}
Sistema: ✅ Operacional

Como posso ajudá-lo?"""
        
        return None
    
    def _generate_fallback_response(self, message: str, intent_result: Dict) -> str:
        """Gera resposta de fallback para intenções não reconhecidas"""
        
        # Analisar se há alguma palavra-chave reconhecida
        all_scores = intent_result.get("all_scores", {})
        
        if all_scores:
            # Sugerir baseado nas intenções com score baixo
            suggestions = []
            for intent, score in sorted(all_scores.items(), key=lambda x: x[1], reverse=True)[:2]:
                if intent == "horario":
                    suggestions.append("horários de funcionamento")
                elif intent == "entrega":
                    suggestions.append("informações sobre entrega")
                elif intent == "produtos":
                    suggestions.append("consulta de produtos")
                elif intent == "localizacao":
                    suggestions.append("localização das lojas")
            
            if suggestions:
                return f"""Não tenho certeza do que você precisa, mas posso ajudar com:

• {chr(10).join([f'{sug}' for sug in suggestions])}

Ou digite "ajuda" para ver todas as opções!"""
        
        # Resposta genérica
        return """Obrigado pela sua mensagem! 

Sou o assistente virtual do Novo Atacarejo e posso ajudar com:
• Horários de funcionamento
• Informações sobre entrega  
• Localização das lojas
• Formas de pagamento
• Produtos e ofertas

Como posso auxiliá-lo?"""
    
    def _get_cached_response(self, message: str) -> Optional[str]:
        """Busca resposta no cache"""
        message_key = message.lower().strip()
        return self.response_cache.get(message_key)
    
    def _cache_response(self, message: str, response: str):
        """Armazena resposta no cache"""
        message_key = message.lower().strip()
        
        # Limitar tamanho do cache
        if len(self.response_cache) >= 100:
            # Remover entrada mais antiga (implementação simples)
            oldest_key = next(iter(self.response_cache))
            del self.response_cache[oldest_key]
        
        self.response_cache[message_key] = response
    
    def _update_conversation_context(self, user_number: str, user_message: str, bot_response: str):
        """Atualiza contexto da conversa"""
        if user_number not in self.conversations:
            self.conversations[user_number] = []
        
        self.conversations[user_number].append({
            "timestamp": datetime.now().isoformat(),
            "user": user_message,
            "bot": bot_response
        })
        
        # Manter apenas as últimas 5 interações
        if len(self.conversations[user_number]) > 5:
            self.conversations[user_number] = self.conversations[user_number][-5:]
    
    def get_conversation_stats(self) -> Dict:
        """Obtém estatísticas das conversas"""
        total_conversations = len(self.conversations)
        total_messages = sum(len(conv) for conv in self.conversations.values())
        cache_hits = len(self.response_cache)
        
        return {
            "total_users": total_conversations,
            "total_messages": total_messages,
            "cache_size": cache_hits,
            "avg_messages_per_user": total_messages / max(total_conversations, 1)
        }
```

## **4.4. Integração Completa**

### **Arquivo atualizado: `app.py`**

```python
from fastapi import FastAPI, Request, HTTPException, Query
from fastapi.responses import PlainTextResponse
import logging
import json
import uvicorn
import os
from datetime import datetime
from src.smart_chatbot import SmartChatbot

# Configurar logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('logs/chatbot.log'),
        logging.StreamHandler()
    ]
)

# Inicializar aplicação
app = FastAPI(title="WhatsApp LLaMA Chatbot Inteligente", version="2.0.0")

# Instância do chatbot inteligente
smart_chatbot = SmartChatbot()

@app.get("/")
def root():
    """Endpoint raiz"""
    return {
        "message": "WhatsApp LLaMA Chatbot Inteligente está rodando!",
        "version": "2.0.0",
        "status": "online",
        "features": [
            "Classificação de intenções",
            "Base de conhecimento personalizada",
            "Cache de respostas",
            "Contexto de conversa"
        ]
    }

@app.get("/webhook")
def verify_webhook(
    hub_mode: str = Query(alias="hub.mode"),
    hub_verify_token: str = Query(alias="hub.verify_token"), 
    hub_challenge: str = Query(alias="hub.challenge")
):
    """Verificação do webhook do WhatsApp"""
    try:
        VERIFY_TOKEN = "meu_token_webhook_123"
        
        if hub_mode == "subscribe" and hub_verify_token == VERIFY_TOKEN:
            logging.info("Webhook verificado com sucesso")
            return PlainTextResponse(hub_challenge)
        else:
            logging.error("Token de verificação inválido")
            raise HTTPException(status_code=403, detail="Proibido")
            
    except Exception as e:
        logging.error(f"Erro na verificação do webhook: {e}")
        raise HTTPException(status_code=500, detail="Erro Interno do Servidor")

@app.post("/webhook")
async def receive_message(request: Request):
    """Recebe mensagens do WhatsApp via webhook"""
    try:
        webhook_data = await request.json()
        logging.info(f"Webhook recebido: {json.dumps(webhook_data, indent=2)}")
        
        # Processar com chatbot inteligente
        success = smart_chatbot.process_message(webhook_data)
        
        if success:
            return {"status": "success", "message": "Mensagem processada com IA"}
        else:
            return {"status": "error", "message": "Falha ao processar mensagem"}
            
    except Exception as e:
        logging.error(f"Erro ao processar webhook: {e}")
        raise HTTPException(status_code=500, detail="Erro Interno do Servidor")

@app.get("/health")
def health_check():
    """Endpoint de verificação de saúde"""
    try:
        stats = smart_chatbot.get_conversation_stats()
        
        return {
            "status": "healthy",
            "components": {
                "api": True,
                "chatbot": True,
                "intent_classifier": True
            },
            "stats": stats,
            "timestamp": datetime.now().isoformat()
        }
    except Exception as e:
        return {
            "status": "unhealthy",
            "error": str(e),
            "timestamp": datetime.now().isoformat()
        }

@app.post("/test-message")
async def test_message(request: Request):
    """Endpoint para testar processamento de mensagens"""
    try:
        data = await request.json()
        
        test_webhook = {
            "entry": [{
                "changes": [{
                    "value": {
                        "messages": [{
                            "from": data.get("from", "5511999999999"),
                            "text": {"body": data.get("message", "Olá!")},
                            "type": "text"
                        }]
                    }
                }]
            }]
        }
        
        success = smart_chatbot.process_message(test_webhook)
        
        return {
            "status": "success" if success else "error",
            "message": "Teste processado com IA",
            "intelligent_features": "Ativado"
        }
        
    except Exception as e:
        logging.error(f"Erro no teste: {e}")
        raise HTTPException(status_code=500, detail="Erro Interno do Servidor")

@app.get("/stats")
def get_stats():
    """Endpoint para estatísticas detalhadas"""
    try:
        stats = smart_chatbot.get_conversation_stats()
        return {
            "conversation_stats": stats,
            "system_info": {
                "cache_enabled": True,
                "intent_classification": True,
                "knowledge_base": True
            }
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

if __name__ == "__main__":
    # Criar diretórios necessários
    os.makedirs("logs", exist_ok=True)
    os.makedirs("data", exist_ok=True)
    os.makedirs("config", exist_ok=True)
    
    # Executar servidor
    uvicorn.run(
        "app:app",
        host="0.0.0.0",
        port=5000,
        reload=True,
        log_level="info"
    )
```

## **4.5. Script de Setup Completo**

### **Arquivo: `setup_personalization.py`**

```python
#!/usr/bin/env python3

import os
import json

def setup_personalized_chatbot():
    """Configura chatbot personalizado completo"""
    
    print("🚀 Configurando Chatbot Personalizado - Novo Atacarejo")
    print("=" * 60)
    
    # Criar estrutura de diretórios
    directories = ["src", "data", "config", "logs"]
    for directory in directories:
        os.makedirs(directory, exist_ok=True)
        print(f"✅ Diretório {directory} criado")
    
    # Criar arquivo __init__.py para o módulo src
    with open("src/__init__.py", "w") as f:
        f.write("# Módulo do chatbot personalizado\n")
    
    print("\n📝 Criando arquivos de configuração...")
    
    # Arquivo de configuração da personalidade
    personality_config = {
        "company_info": {
            "name": "Novo Atacarejo",
            "business_type": "Rede de atacado e varejo",
            "values": ["qualidade", "preço justo", "atendimento excelente"],
            "tone": "profissional, amigável e prestativo"
        },
        "chatbot_personality": {
            "name": "Assistente Virtual Novo Atacarejo",
            "greeting_style": "cordial e profissional",
            "response_style": "claro, objetivo e útil",
            "fallback_behavior": "sempre oferecer alternativas de ajuda"
        }
    }
    
    with open("config/personality_config.json", "w", encoding="utf-8") as f:
        json.dump(personality_config, f, ensure_ascii=False, indent=2)
    
    # Base de conhecimento
    knowledge_base = {
        "produtos": {
            "categorias": [
                "Alimentos básicos (arroz, feijão, açúcar, óleo)",
                "Bebidas (refrigerantes, sucos, água, cervejas)", 
                "Limpeza (detergentes, sabão, desinfetantes)",
                "Higiene pessoal (shampoo, sabonete, pasta de dente)",
                "Frios e laticínios (queijos, presunto, leite, iogurte)"
            ],
            "ofertas_especiais": [
                "Quarta-feira: 20% desconto em produtos de limpeza",
                "Sexta da carne: descontos especiais em carnes",
                "Combo família: 15% desconto acima de R$ 200"
            ]
        },
        "servicos": {
            "entrega": {
                "disponivel": True,
                "taxa": "R$ 8,00 para compras abaixo de R$ 100",
                "gratuita": "Compras acima de R$ 100",
                "prazo": "2-4 horas dentro da cidade"
            },
            "pagamento": ["Dinheiro", "PIX", "Cartão de débito", "Cartão de crédito", "Vale alimentação"],
            "horarios": {
                "segunda_sabado": "8h às 20h",
                "domingo": "8h às 14h",
                "feriados": "Consultar previamente"
            }
        },
        "localizacao": {
            "enderecos": [
                "Loja Centro: Rua Principal, 123 - Centro",
                "Loja Norte: Av. Norte, 456 - Bairro Norte",
                "Loja Sul: Rua Sul, 789 - Bairro Sul"
            ],
            "telefone": "(11) 1234-5678",
            "whatsapp": "(11) 99999-9999"
        }
    }
    
    with open("data/knowledge_base.json", "w", encoding="utf-8") as f:
        json.dump(knowledge_base, f, ensure_ascii=False, indent=2)
    
    print("✅ Arquivos de configuração criados")
    
    # Criar script de teste
    test_script = '''#!/usr/bin/env python3

import sys
import os
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

def test_personalized_chatbot():
    """Testa chatbot personalizado"""
    
    print("🧪 Testando Chatbot Personalizado")
    print("=" * 40)
    
    try:
        from src.intent_classifier import IntentClassifier
        from src.smart_chatbot import SmartChatbot
        
        # Testar classificador de intenções
        print("\\n1. Testando classificador de intenções...")
        classifier = IntentClassifier()
        
        test_messages = [
            "Olá, bom dia!",
            "Qual o horário de funcionamento?",
            "Vocês fazem entrega?",
            "Quanto custa o arroz?",
            "Onde fica a loja?",
            "Preciso de ajuda"
        ]
        
        for message in test_messages:
            result = classifier.classify_intent(message)
            print(f"  '{message}' -> {result['intent']} (confiança: {result['confidence']:.2f})")
        
        # Testar chatbot completo
        print("\\n2. Testando chatbot inteligente...")
        chatbot = SmartChatbot()
        
        # Simular webhook
        test_webhook = {
            "entry": [{
                "changes": [{
                    "value": {
                        "messages": [{
                            "from": "5511999999999",
                            "text": {"body": "Qual o horário de funcionamento?"},
                            "type": "text"
                        }]
                    }
                }]
            }]
        }
        
        success = chatbot.process_message(test_webhook)
        print(f"  Processamento de mensagem: {'✅ Sucesso' if success else '❌ Erro'}")
        
        # Estatísticas
        stats = chatbot.get_conversation_stats()
        print(f"  Usuários ativos: {stats['total_users']}")
        print(f"  Cache de respostas: {stats['cache_size']}")
        
        print("\\n✅ Todos os testes passaram!")
        print("\\n🚀 Para iniciar o chatbot:")
        print("   python app.py")
        
    except ImportError as e:
        print(f"❌ Erro de importação: {e}")
        print("Certifique-se de que todos os arquivos foram criados corretamente.")
    except Exception as e:
        print(f"❌ Erro durante o teste: {e}")

if __name__ == "__main__":
    test_personalized_chatbot()
'''
    
    with open("test_personalized_chatbot.py", "w", encoding="utf-8") as f:
        f.write(test_script)
    
    os.chmod("test_personalized_chatbot.py", 0o755)
    
    print("✅ Script de teste criado")
    
    # Atualizar requirements.txt
    requirements = """fastapi>=0.100.0
uvicorn>=0.22.0
requests>=2.31.0
python-multipart>=0.0.6
"""
    
    with open("requirements.txt", "w") as f:
        f.write(requirements)
    
    print("✅ Requirements.txt atualizado")
    
    print("\n🎉 Configuração completa!")
    print("\nPróximos passos:")
    print("1. Instale as dependências: pip install -r requirements.txt")
    print("2. Execute o teste: python test_personalized_chatbot.py") 
    print("3. Inicie o chatbot: python app.py")
    print("4. Teste no navegador: http://localhost:5000")

if __name__ == "__main__":
    setup_personalized_chatbot()
```

---

**✅ Parabéns!** Seu chatbot está agora completamente personalizado para o Novo Atacarejo!

**🎯 O que foi implementado:**
- ✅ Personalidade e prompts específicos da empresa
- ✅ Base de conhecimento customizada  
- ✅ Sistema de classificação de intenções
- ✅ Cache inteligente de respostas
- ✅ Contexto de conversas
- ✅ Respostas baseadas em conhecimento específico

**🚀 Funcionalidades avançadas:**
- Classificação automática de intenções do usuário
- Respostas contextualizadas sobre a empresa
- Sistema de cache para respostas frequentes
- Comandos especiais para administração
- Estatísticas de uso em tempo real

**Execute o setup:**
```bash
python setup_personalization.py
python test_personalized_chatbot.py
python app.py
```

**Na próxima seção**, vamos configurar o monitoramento e manutenção para garantir que o chatbot funcione perfeitamente em produção!
