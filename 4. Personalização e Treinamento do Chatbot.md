# **4. PersonalizaÃ§Ã£o e Treinamento do Chatbot**

Agora que temos a integraÃ§Ã£o funcionando, vamos personalizar o chatbot para atender Ã s necessidades especÃ­ficas da empresa Novo Atacarejo. Esta seÃ§Ã£o cobrirÃ¡ personalizaÃ§Ã£o de respostas, criaÃ§Ã£o de conhecimento especÃ­fico, treinamento com dados customizados e otimizaÃ§Ã£o de performance.

## **4.1. PersonalizaÃ§Ã£o de Prompts e Personalidade**

### **Definindo a Personalidade do Chatbot**

Vamos criar uma personalidade consistente e profissional para o assistente virtual:

#### **Arquivo: `config/personality_config.json`**

```json
{
  "company_info": {
    "name": "Novo Atacarejo",
    "business_type": "Rede de atacado e varejo",
    "values": ["qualidade", "preÃ§o justo", "atendimento excelente"],
    "tone": "profissional, amigÃ¡vel e prestativo"
  },
  "chatbot_personality": {
    "name": "Assistente Virtual Novo Atacarejo",
    "greeting_style": "cordial e profissional",
    "response_style": "claro, objetivo e Ãºtil",
    "fallback_behavior": "sempre oferecer alternativas de ajuda"
  },
  "response_templates": {
    "greeting": [
      "OlÃ¡! Sou o assistente virtual do Novo Atacarejo. Como posso ajudÃ¡-lo hoje?",
      "Bem-vindo ao Novo Atacarejo! Em que posso auxiliÃ¡-lo?",
      "Oi! Ã‰ um prazer atendÃª-lo. Como posso ajudar?"
    ],
    "farewell": [
      "Foi um prazer ajudÃ¡-lo! Volte sempre ao Novo Atacarejo!",
      "Obrigado por escolher o Novo Atacarejo. Tenha um Ã³timo dia!",
      "AtÃ© logo! Estamos sempre aqui quando precisar."
    ],
    "unknown": [
      "NÃ£o tenho essa informaÃ§Ã£o especÃ­fica, mas posso conectÃ¡-lo com nossa equipe.",
      "Vou verificar isso para vocÃª. Enquanto isso, posso ajudar com algo mais?",
      "Ã“tima pergunta! Deixe-me consultar nossos especialistas sobre isso."
    ]
  }
}
```

### **Sistema de Conhecimento da Empresa**

#### **Arquivo: `data/knowledge_base.json`**

```json
{
  "produtos": {
    "categorias": [
      "Alimentos bÃ¡sicos (arroz, feijÃ£o, aÃ§Ãºcar, Ã³leo)",
      "Bebidas (refrigerantes, sucos, Ã¡gua, cervejas)",
      "Limpeza (detergentes, sabÃ£o, desinfetantes)",
      "Higiene pessoal (shampoo, sabonete, pasta de dente)",
      "Frios e laticÃ­nios (queijos, presunto, leite, iogurte)",
      "Frutas e verduras frescas",
      "Produtos de padaria",
      "Carnes e aves"
    ],
    "ofertas_especiais": [
      "PromoÃ§Ãµes de quarta-feira: 20% desconto em produtos de limpeza",
      "Sexta-feira da carne: descontos especiais em carnes",
      "Combo famÃ­lia: 15% desconto comprando acima de R$ 200"
    ]
  },
  "servicos": {
    "entrega": {
      "disponivel": true,
      "taxa": "R$ 8,00 para compras abaixo de R$ 100",
      "gratuita": "Compras acima de R$ 100",
      "prazo": "2-4 horas dentro da cidade"
    },
    "pagamento": [
      "Dinheiro", "PIX", "CartÃ£o de dÃ©bito", 
      "CartÃ£o de crÃ©dito", "Vale alimentaÃ§Ã£o"
    ],
    "horarios": {
      "segunda_sabado": "8h Ã s 20h",
      "domingo": "8h Ã s 14h",
      "feriados": "Consultar previamente"
    }
  },
  "localizacao": {
    "enderecos": [
      "Loja Centro: Rua Principal, 123 - Centro",
      "Loja Norte: Av. Norte, 456 - Bairro Norte", 
      "Loja Sul: Rua Sul, 789 - Bairro Sul"
    ],
    "telefone": "(11) 1234-5678",
    "whatsapp": "(11) 99999-9999"
  },
  "politicas": {
    "troca_devolucao": "7 dias para produtos nÃ£o perecÃ­veis com nota fiscal",
    "garantia": "Conforme fabricante para eletrodomÃ©sticos",
    "privacidade": "Dados protegidos conforme LGPD"
  }
}
```

## **4.2. Sistema de ClassificaÃ§Ã£o de IntenÃ§Ãµes**

### **Arquivo: `src/intent_classifier.py`**

```python
import json
import re
from typing import Dict, List, Tuple

class IntentClassifier:
    def __init__(self, config_path="data/knowledge_base.json"):
        """
        Classificador de intenÃ§Ãµes para o chatbot
        """
        self.knowledge_base = self._load_knowledge_base(config_path)
        self.intent_patterns = self._build_intent_patterns()
    
    def _load_knowledge_base(self, config_path):
        """Carrega base de conhecimento"""
        try:
            with open(config_path, 'r', encoding='utf-8') as f:
                return json.load(f)
        except FileNotFoundError:
            return {}
    
    def _build_intent_patterns(self):
        """ConstrÃ³i padrÃµes para classificaÃ§Ã£o de intenÃ§Ãµes"""
        return {
            "greeting": {
                "keywords": ["olÃ¡", "oi", "bom dia", "boa tarde", "boa noite", "hey", "hello"],
                "patterns": [r"\b(ola|oi|bom\s+dia|boa\s+tarde|boa\s+noite)\b"]
            },
            "farewell": {
                "keywords": ["tchau", "bye", "atÃ© logo", "obrigado", "valeu", "adeus"],
                "patterns": [r"\b(tchau|bye|ate\s+logo|obrigad[oa])\b"]
            },
            "horario": {
                "keywords": ["horÃ¡rio", "horario", "funcionamento", "aberto", "fecha", "abre", "que horas"],
                "patterns": [r"\b(horario|funcionamento|que\s+horas|aberto|fecha)\b"]
            },
            "entrega": {
                "keywords": ["entrega", "delivery", "entregar", "levar", "frete", "envio"],
                "patterns": [r"\b(entrega|delivery|frete|envio)\b"]
            },
            "produtos": {
                "keywords": ["produto", "vende", "tem", "estoque", "disponÃ­vel", "preÃ§o", "valor", "custa"],
                "patterns": [r"\b(produto|preco|valor|custa|tem|vende)\b"]
            },
            "pagamento": {
                "keywords": ["pagamento", "pagar", "cartÃ£o", "dinheiro", "pix", "dÃ©bito", "crÃ©dito"],
                "patterns": [r"\b(pagamento|pagar|cartao|dinheiro|pix)\b"]
            },
            "localizacao": {
                "keywords": ["endereÃ§o", "endereco", "onde", "localizaÃ§Ã£o", "loja", "fica"],
                "patterns": [r"\b(endereco|onde|localizacao|loja|fica)\b"]
            },
            "ofertas": {
                "keywords": ["promoÃ§Ã£o", "desconto", "oferta", "barato", "promoÃ§Ãµes"],
                "patterns": [r"\b(promocao|desconto|oferta|barato)\b"]
            },
            "help": {
                "keywords": ["ajuda", "help", "comandos", "o que pode", "como funciona"],
                "patterns": [r"\b(ajuda|help|comandos|como\s+funciona)\b"]
            }
        }
    
    def classify_intent(self, message: str) -> Dict[str, any]:
        """
        Classifica a intenÃ§Ã£o da mensagem
        
        ParÃ¢metros:
            message: Mensagem do usuÃ¡rio
            
        Retorna:
            dict: IntenÃ§Ã£o classificada com confianÃ§a
        """
        message_clean = self._clean_message(message)
        intent_scores = {}
        
        # Calcular scores para cada intenÃ§Ã£o
        for intent, config in self.intent_patterns.items():
            score = 0
            
            # Score por palavras-chave
            for keyword in config["keywords"]:
                if keyword in message_clean:
                    score += 1
            
            # Score por padrÃµes regex
            for pattern in config["patterns"]:
                if re.search(pattern, message_clean, re.IGNORECASE):
                    score += 2  # PadrÃµes tÃªm peso maior
            
            if score > 0:
                intent_scores[intent] = score / (len(config["keywords"]) + len(config["patterns"]))
        
        # Retornar intenÃ§Ã£o com maior score
        if intent_scores:
            best_intent = max(intent_scores, key=intent_scores.get)
            confidence = intent_scores[best_intent]
            
            return {
                "intent": best_intent,
                "confidence": min(confidence, 1.0),  # Limitar a 1.0
                "all_scores": intent_scores
            }
        
        return {"intent": "unknown", "confidence": 0.0, "all_scores": {}}
    
    def _clean_message(self, message: str) -> str:
        """Limpa e normaliza mensagem para anÃ¡lise"""
        # Converter para minÃºsculas
        message = message.lower()
        
        # Remover acentos bÃ¡sicos
        replacements = {
            'Ã£': 'a', 'Ã¡': 'a', 'Ã ': 'a', 'Ã¢': 'a',
            'Ã©': 'e', 'Ãª': 'e', 'Ã­': 'i', 'Ã³': 'o',
            'Ã´': 'o', 'Ãµ': 'o', 'Ãº': 'u', 'Ã§': 'c'
        }
        
        for old, new in replacements.items():
            message = message.replace(old, new)
        
        return message
    
    def get_knowledge_response(self, intent: str, message: str = None) -> str:
        """
        Gera resposta baseada na base de conhecimento
        
        ParÃ¢metros:
            intent: IntenÃ§Ã£o classificada
            message: Mensagem original (para contexto)
            
        Retorna:
            str: Resposta baseada no conhecimento
        """
        if intent == "horario":
            horarios = self.knowledge_base.get("servicos", {}).get("horarios", {})
            return f"""ğŸ• **HorÃ¡rios de Funcionamento:**
â€¢ Segunda a sÃ¡bado: {horarios.get("segunda_sabado", "8h Ã s 20h")}
â€¢ Domingo: {horarios.get("domingo", "8h Ã s 14h")}
â€¢ Feriados: {horarios.get("feriados", "Consultar previamente")}"""

        elif intent == "entrega":
            entrega = self.knowledge_base.get("servicos", {}).get("entrega", {})
            return f"""ğŸšš **ServiÃ§o de Entrega:**
â€¢ Taxa: {entrega.get("taxa", "R$ 8,00")}
â€¢ Entrega gratuita: {entrega.get("gratuita", "Compras acima de R$ 100")}
â€¢ Prazo: {entrega.get("prazo", "2-4 horas")}"""

        elif intent == "produtos":
            categorias = self.knowledge_base.get("produtos", {}).get("categorias", [])
            return f"""ğŸ›’ **Nossos Produtos:**
{chr(10).join([f'â€¢ {cat}' for cat in categorias[:5]])}
... e muito mais! O que vocÃª procura especificamente?"""

        elif intent == "pagamento":
            pagamentos = self.knowledge_base.get("servicos", {}).get("pagamento", [])
            return f"""ğŸ’³ **Formas de Pagamento:**
{chr(10).join([f'â€¢ {pag}' for pag in pagamentos])}"""

        elif intent == "localizacao":
            enderecos = self.knowledge_base.get("localizacao", {}).get("enderecos", [])
            telefone = self.knowledge_base.get("localizacao", {}).get("telefone", "")
            return f"""ğŸ“ **Nossas Lojas:**
{chr(10).join([f'â€¢ {end}' for end in enderecos])}

ğŸ“ Central: {telefone}"""

        elif intent == "ofertas":
            ofertas = self.knowledge_base.get("produtos", {}).get("ofertas_especiais", [])
            return f"""ğŸ·ï¸ **Ofertas Especiais:**
{chr(10).join([f'â€¢ {oferta}' for oferta in ofertas])}"""

        elif intent == "help":
            return """ğŸ¤– **Assistente Virtual - Novo Atacarejo**

Posso ajudar com:
â€¢ Consulta de horÃ¡rios
â€¢ InformaÃ§Ãµes sobre entrega
â€¢ LocalizaÃ§Ã£o das lojas
â€¢ Formas de pagamento
â€¢ Produtos e ofertas

Digite sua dÃºvida!"""

        else:
            return "Como posso ajudÃ¡-lo hoje? Estou aqui para responder suas dÃºvidas sobre o Novo Atacarejo!"
```

## **4.3. Chatbot Inteligente Melhorado**

### **Arquivo: `src/smart_chatbot.py`**

```python
import logging
import time
from datetime import datetime
from typing import Dict, List, Optional
from .intent_classifier import IntentClassifier

class SmartChatbot:
    def __init__(self):
        """
        Chatbot inteligente com classificaÃ§Ã£o de intenÃ§Ãµes
        """
        self.logger = logging.getLogger(__name__)
        self.intent_classifier = IntentClassifier()
        self.conversations = {}  # Armazenar contexto das conversas
        self.response_cache = {}  # Cache de respostas
        
        self.logger.info("SmartChatbot inicializado com sucesso")
    
    def process_message(self, webhook_data: Dict) -> bool:
        """
        Processa mensagem recebida via webhook com IA
        
        ParÃ¢metros:
            webhook_data: Dados do webhook
            
        Retorna:
            bool: True se processada com sucesso
        """
        try:
            # Parse da mensagem
            message_data = self._parse_webhook_message(webhook_data)
            
            if not message_data:
                self.logger.warning("Mensagem invÃ¡lida ou nÃ£o suportada")
                return False
            
            user_number = message_data["from"]
            user_message = message_data["text"]
            
            self.logger.info(f"Processando mensagem de {user_number}: {user_message[:50]}...")
            
            # Verificar cache de resposta
            cached_response = self._get_cached_response(user_message)
            if cached_response:
                self.logger.info("Resposta encontrada no cache")
                response = cached_response
            else:
                # Gerar nova resposta
                response = self._generate_intelligent_response(user_message, user_number)
                self._cache_response(user_message, response)
            
            # Atualizar contexto da conversa
            self._update_conversation_context(user_number, user_message, response)
            
            # Em produÃ§Ã£o, aqui enviaria via WhatsApp API
            self.logger.info(f"Resposta gerada: {response[:100]}...")
            
            return True
            
        except Exception as e:
            self.logger.error(f"Erro ao processar mensagem: {e}")
            return False
    
    def _parse_webhook_message(self, webhook_data: Dict) -> Optional[Dict]:
        """Parse de mensagem do webhook"""
        try:
            entry = webhook_data.get("entry", [])
            if not entry:
                return None
            
            changes = entry[0].get("changes", [])
            if not changes:
                return None
            
            value = changes[0].get("value", {})
            messages = value.get("messages", [])
            
            if not messages:
                return None
            
            message_data = messages[0]
            
            return {
                "from": message_data.get("from"),
                "text": message_data.get("text", {}).get("body", ""),
                "type": message_data.get("type", "text")
            }
            
        except Exception as e:
            self.logger.error(f"Erro ao processar webhook: {e}")
            return None
    
    def _generate_intelligent_response(self, message: str, user_number: str) -> str:
        """
        Gera resposta inteligente usando classificaÃ§Ã£o de intenÃ§Ãµes
        
        ParÃ¢metros:
            message: Mensagem do usuÃ¡rio
            user_number: NÃºmero do usuÃ¡rio
            
        Retorna:
            str: Resposta gerada
        """
        # Verificar comandos especiais primeiro
        special_response = self._handle_special_commands(message, user_number)
        if special_response:
            return special_response
        
        # Classificar intenÃ§Ã£o
        intent_result = self.intent_classifier.classify_intent(message)
        intent = intent_result["intent"]
        confidence = intent_result["confidence"]
        
        self.logger.info(f"IntenÃ§Ã£o detectada: {intent} (confianÃ§a: {confidence:.2f})")
        
        # Gerar resposta baseada na intenÃ§Ã£o
        if confidence >= 0.3:  # Threshold de confianÃ§a
            knowledge_response = self.intent_classifier.get_knowledge_response(intent, message)
            if knowledge_response:
                return knowledge_response
        
        # Fallback para intenÃ§Ãµes nÃ£o reconhecidas
        return self._generate_fallback_response(message, intent_result)
    
    def _handle_special_commands(self, message: str, user_number: str) -> Optional[str]:
        """Processa comandos especiais"""
        message_lower = message.lower().strip()
        
        if message_lower in ["/reset", "reset", "limpar conversa"]:
            if user_number in self.conversations:
                del self.conversations[user_number]
            return "Conversa reiniciada! Como posso ajudÃ¡-lo?"
        
        if message_lower in ["/status", "status"]:
            cache_size = len(self.response_cache)
            conversations = len(self.conversations)
            
            return f"""ğŸ“Š **Status do Sistema**

Cache de respostas: {cache_size}
Conversas ativas: {conversations}
Sistema: âœ… Operacional

Como posso ajudÃ¡-lo?"""
        
        return None
    
    def _generate_fallback_response(self, message: str, intent_result: Dict) -> str:
        """Gera resposta de fallback para intenÃ§Ãµes nÃ£o reconhecidas"""
        
        # Analisar se hÃ¡ alguma palavra-chave reconhecida
        all_scores = intent_result.get("all_scores", {})
        
        if all_scores:
            # Sugerir baseado nas intenÃ§Ãµes com score baixo
            suggestions = []
            for intent, score in sorted(all_scores.items(), key=lambda x: x[1], reverse=True)[:2]:
                if intent == "horario":
                    suggestions.append("horÃ¡rios de funcionamento")
                elif intent == "entrega":
                    suggestions.append("informaÃ§Ãµes sobre entrega")
                elif intent == "produtos":
                    suggestions.append("consulta de produtos")
                elif intent == "localizacao":
                    suggestions.append("localizaÃ§Ã£o das lojas")
            
            if suggestions:
                return f"""NÃ£o tenho certeza do que vocÃª precisa, mas posso ajudar com:

â€¢ {chr(10).join([f'{sug}' for sug in suggestions])}

Ou digite "ajuda" para ver todas as opÃ§Ãµes!"""
        
        # Resposta genÃ©rica
        return """Obrigado pela sua mensagem! 

Sou o assistente virtual do Novo Atacarejo e posso ajudar com:
â€¢ HorÃ¡rios de funcionamento
â€¢ InformaÃ§Ãµes sobre entrega  
â€¢ LocalizaÃ§Ã£o das lojas
â€¢ Formas de pagamento
â€¢ Produtos e ofertas

Como posso auxiliÃ¡-lo?"""
    
    def _get_cached_response(self, message: str) -> Optional[str]:
        """Busca resposta no cache"""
        message_key = message.lower().strip()
        return self.response_cache.get(message_key)
    
    def _cache_response(self, message: str, response: str):
        """Armazena resposta no cache"""
        message_key = message.lower().strip()
        
        # Limitar tamanho do cache
        if len(self.response_cache) >= 100:
            # Remover entrada mais antiga (implementaÃ§Ã£o simples)
            oldest_key = next(iter(self.response_cache))
            del self.response_cache[oldest_key]
        
        self.response_cache[message_key] = response
    
    def _update_conversation_context(self, user_number: str, user_message: str, bot_response: str):
        """Atualiza contexto da conversa"""
        if user_number not in self.conversations:
            self.conversations[user_number] = []
        
        self.conversations[user_number].append({
            "timestamp": datetime.now().isoformat(),
            "user": user_message,
            "bot": bot_response
        })
        
        # Manter apenas as Ãºltimas 5 interaÃ§Ãµes
        if len(self.conversations[user_number]) > 5:
            self.conversations[user_number] = self.conversations[user_number][-5:]
    
    def get_conversation_stats(self) -> Dict:
        """ObtÃ©m estatÃ­sticas das conversas"""
        total_conversations = len(self.conversations)
        total_messages = sum(len(conv) for conv in self.conversations.values())
        cache_hits = len(self.response_cache)
        
        return {
            "total_users": total_conversations,
            "total_messages": total_messages,
            "cache_size": cache_hits,
            "avg_messages_per_user": total_messages / max(total_conversations, 1)
        }
```

## **4.4. IntegraÃ§Ã£o Completa**

### **Arquivo atualizado: `app.py`**

```python
from fastapi import FastAPI, Request, HTTPException, Query
from fastapi.responses import PlainTextResponse
import logging
import json
import uvicorn
import os
from datetime import datetime
from src.smart_chatbot import SmartChatbot

# Configurar logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('logs/chatbot.log'),
        logging.StreamHandler()
    ]
)

# Inicializar aplicaÃ§Ã£o
app = FastAPI(title="WhatsApp LLaMA Chatbot Inteligente", version="2.0.0")

# InstÃ¢ncia do chatbot inteligente
smart_chatbot = SmartChatbot()

@app.get("/")
def root():
    """Endpoint raiz"""
    return {
        "message": "WhatsApp LLaMA Chatbot Inteligente estÃ¡ rodando!",
        "version": "2.0.0",
        "status": "online",
        "features": [
            "ClassificaÃ§Ã£o de intenÃ§Ãµes",
            "Base de conhecimento personalizada",
            "Cache de respostas",
            "Contexto de conversa"
        ]
    }

@app.get("/webhook")
def verify_webhook(
    hub_mode: str = Query(alias="hub.mode"),
    hub_verify_token: str = Query(alias="hub.verify_token"), 
    hub_challenge: str = Query(alias="hub.challenge")
):
    """VerificaÃ§Ã£o do webhook do WhatsApp"""
    try:
        VERIFY_TOKEN = "meu_token_webhook_123"
        
        if hub_mode == "subscribe" and hub_verify_token == VERIFY_TOKEN:
            logging.info("Webhook verificado com sucesso")
            return PlainTextResponse(hub_challenge)
        else:
            logging.error("Token de verificaÃ§Ã£o invÃ¡lido")
            raise HTTPException(status_code=403, detail="Proibido")
            
    except Exception as e:
        logging.error(f"Erro na verificaÃ§Ã£o do webhook: {e}")
        raise HTTPException(status_code=500, detail="Erro Interno do Servidor")

@app.post("/webhook")
async def receive_message(request: Request):
    """Recebe mensagens do WhatsApp via webhook"""
    try:
        webhook_data = await request.json()
        logging.info(f"Webhook recebido: {json.dumps(webhook_data, indent=2)}")
        
        # Processar com chatbot inteligente
        success = smart_chatbot.process_message(webhook_data)
        
        if success:
            return {"status": "success", "message": "Mensagem processada com IA"}
        else:
            return {"status": "error", "message": "Falha ao processar mensagem"}
            
    except Exception as e:
        logging.error(f"Erro ao processar webhook: {e}")
        raise HTTPException(status_code=500, detail="Erro Interno do Servidor")

@app.get("/health")
def health_check():
    """Endpoint de verificaÃ§Ã£o de saÃºde"""
    try:
        stats = smart_chatbot.get_conversation_stats()
        
        return {
            "status": "healthy",
            "components": {
                "api": True,
                "chatbot": True,
                "intent_classifier": True
            },
            "stats": stats,
            "timestamp": datetime.now().isoformat()
        }
    except Exception as e:
        return {
            "status": "unhealthy",
            "error": str(e),
            "timestamp": datetime.now().isoformat()
        }

@app.post("/test-message")
async def test_message(request: Request):
    """Endpoint para testar processamento de mensagens"""
    try:
        data = await request.json()
        
        test_webhook = {
            "entry": [{
                "changes": [{
                    "value": {
                        "messages": [{
                            "from": data.get("from", "5511999999999"),
                            "text": {"body": data.get("message", "OlÃ¡!")},
                            "type": "text"
                        }]
                    }
                }]
            }]
        }
        
        success = smart_chatbot.process_message(test_webhook)
        
        return {
            "status": "success" if success else "error",
            "message": "Teste processado com IA",
            "intelligent_features": "Ativado"
        }
        
    except Exception as e:
        logging.error(f"Erro no teste: {e}")
        raise HTTPException(status_code=500, detail="Erro Interno do Servidor")

@app.get("/stats")
def get_stats():
    """Endpoint para estatÃ­sticas detalhadas"""
    try:
        stats = smart_chatbot.get_conversation_stats()
        return {
            "conversation_stats": stats,
            "system_info": {
                "cache_enabled": True,
                "intent_classification": True,
                "knowledge_base": True
            }
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

if __name__ == "__main__":
    # Criar diretÃ³rios necessÃ¡rios
    os.makedirs("logs", exist_ok=True)
    os.makedirs("data", exist_ok=True)
    os.makedirs("config", exist_ok=True)
    
    # Executar servidor
    uvicorn.run(
        "app:app",
        host="0.0.0.0",
        port=5000,
        reload=True,
        log_level="info"
    )
```

## **4.5. Script de Setup Completo**

### **Arquivo: `setup_personalization.py`**

```python
#!/usr/bin/env python3

import os
import json

def setup_personalized_chatbot():
    """Configura chatbot personalizado completo"""
    
    print("ğŸš€ Configurando Chatbot Personalizado - Novo Atacarejo")
    print("=" * 60)
    
    # Criar estrutura de diretÃ³rios
    directories = ["src", "data", "config", "logs"]
    for directory in directories:
        os.makedirs(directory, exist_ok=True)
        print(f"âœ… DiretÃ³rio {directory} criado")
    
    # Criar arquivo __init__.py para o mÃ³dulo src
    with open("src/__init__.py", "w") as f:
        f.write("# MÃ³dulo do chatbot personalizado\n")
    
    print("\nğŸ“ Criando arquivos de configuraÃ§Ã£o...")
    
    # Arquivo de configuraÃ§Ã£o da personalidade
    personality_config = {
        "company_info": {
            "name": "Novo Atacarejo",
            "business_type": "Rede de atacado e varejo",
            "values": ["qualidade", "preÃ§o justo", "atendimento excelente"],
            "tone": "profissional, amigÃ¡vel e prestativo"
        },
        "chatbot_personality": {
            "name": "Assistente Virtual Novo Atacarejo",
            "greeting_style": "cordial e profissional",
            "response_style": "claro, objetivo e Ãºtil",
            "fallback_behavior": "sempre oferecer alternativas de ajuda"
        }
    }
    
    with open("config/personality_config.json", "w", encoding="utf-8") as f:
        json.dump(personality_config, f, ensure_ascii=False, indent=2)
    
    # Base de conhecimento
    knowledge_base = {
        "produtos": {
            "categorias": [
                "Alimentos bÃ¡sicos (arroz, feijÃ£o, aÃ§Ãºcar, Ã³leo)",
                "Bebidas (refrigerantes, sucos, Ã¡gua, cervejas)", 
                "Limpeza (detergentes, sabÃ£o, desinfetantes)",
                "Higiene pessoal (shampoo, sabonete, pasta de dente)",
                "Frios e laticÃ­nios (queijos, presunto, leite, iogurte)"
            ],
            "ofertas_especiais": [
                "Quarta-feira: 20% desconto em produtos de limpeza",
                "Sexta da carne: descontos especiais em carnes",
                "Combo famÃ­lia: 15% desconto acima de R$ 200"
            ]
        },
        "servicos": {
            "entrega": {
                "disponivel": True,
                "taxa": "R$ 8,00 para compras abaixo de R$ 100",
                "gratuita": "Compras acima de R$ 100",
                "prazo": "2-4 horas dentro da cidade"
            },
            "pagamento": ["Dinheiro", "PIX", "CartÃ£o de dÃ©bito", "CartÃ£o de crÃ©dito", "Vale alimentaÃ§Ã£o"],
            "horarios": {
                "segunda_sabado": "8h Ã s 20h",
                "domingo": "8h Ã s 14h",
                "feriados": "Consultar previamente"
            }
        },
        "localizacao": {
            "enderecos": [
                "Loja Centro: Rua Principal, 123 - Centro",
                "Loja Norte: Av. Norte, 456 - Bairro Norte",
                "Loja Sul: Rua Sul, 789 - Bairro Sul"
            ],
            "telefone": "(11) 1234-5678",
            "whatsapp": "(11) 99999-9999"
        }
    }
    
    with open("data/knowledge_base.json", "w", encoding="utf-8") as f:
        json.dump(knowledge_base, f, ensure_ascii=False, indent=2)
    
    print("âœ… Arquivos de configuraÃ§Ã£o criados")
    
    # Criar script de teste
    test_script = '''#!/usr/bin/env python3

import sys
import os
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

def test_personalized_chatbot():
    """Testa chatbot personalizado"""
    
    print("ğŸ§ª Testando Chatbot Personalizado")
    print("=" * 40)
    
    try:
        from src.intent_classifier import IntentClassifier
        from src.smart_chatbot import SmartChatbot
        
        # Testar classificador de intenÃ§Ãµes
        print("\\n1. Testando classificador de intenÃ§Ãµes...")
        classifier = IntentClassifier()
        
        test_messages = [
            "OlÃ¡, bom dia!",
            "Qual o horÃ¡rio de funcionamento?",
            "VocÃªs fazem entrega?",
            "Quanto custa o arroz?",
            "Onde fica a loja?",
            "Preciso de ajuda"
        ]
        
        for message in test_messages:
            result = classifier.classify_intent(message)
            print(f"  '{message}' -> {result['intent']} (confianÃ§a: {result['confidence']:.2f})")
        
        # Testar chatbot completo
        print("\\n2. Testando chatbot inteligente...")
        chatbot = SmartChatbot()
        
        # Simular webhook
        test_webhook = {
            "entry": [{
                "changes": [{
                    "value": {
                        "messages": [{
                            "from": "5511999999999",
                            "text": {"body": "Qual o horÃ¡rio de funcionamento?"},
                            "type": "text"
                        }]
                    }
                }]
            }]
        }
        
        success = chatbot.process_message(test_webhook)
        print(f"  Processamento de mensagem: {'âœ… Sucesso' if success else 'âŒ Erro'}")
        
        # EstatÃ­sticas
        stats = chatbot.get_conversation_stats()
        print(f"  UsuÃ¡rios ativos: {stats['total_users']}")
        print(f"  Cache de respostas: {stats['cache_size']}")
        
        print("\\nâœ… Todos os testes passaram!")
        print("\\nğŸš€ Para iniciar o chatbot:")
        print("   python app.py")
        
    except ImportError as e:
        print(f"âŒ Erro de importaÃ§Ã£o: {e}")
        print("Certifique-se de que todos os arquivos foram criados corretamente.")
    except Exception as e:
        print(f"âŒ Erro durante o teste: {e}")

if __name__ == "__main__":
    test_personalized_chatbot()
'''
    
    with open("test_personalized_chatbot.py", "w", encoding="utf-8") as f:
        f.write(test_script)
    
    os.chmod("test_personalized_chatbot.py", 0o755)
    
    print("âœ… Script de teste criado")
    
    # Atualizar requirements.txt
    requirements = """fastapi>=0.100.0
uvicorn>=0.22.0
requests>=2.31.0
python-multipart>=0.0.6
"""
    
    with open("requirements.txt", "w") as f:
        f.write(requirements)
    
    print("âœ… Requirements.txt atualizado")
    
    print("\nğŸ‰ ConfiguraÃ§Ã£o completa!")
    print("\nPrÃ³ximos passos:")
    print("1. Instale as dependÃªncias: pip install -r requirements.txt")
    print("2. Execute o teste: python test_personalized_chatbot.py") 
    print("3. Inicie o chatbot: python app.py")
    print("4. Teste no navegador: http://localhost:5000")

if __name__ == "__main__":
    setup_personalized_chatbot()
```

---

**âœ… ParabÃ©ns!** Seu chatbot estÃ¡ agora completamente personalizado para o Novo Atacarejo!

**ğŸ¯ O que foi implementado:**
- âœ… Personalidade e prompts especÃ­ficos da empresa
- âœ… Base de conhecimento customizada  
- âœ… Sistema de classificaÃ§Ã£o de intenÃ§Ãµes
- âœ… Cache inteligente de respostas
- âœ… Contexto de conversas
- âœ… Respostas baseadas em conhecimento especÃ­fico

**ğŸš€ Funcionalidades avanÃ§adas:**
- ClassificaÃ§Ã£o automÃ¡tica de intenÃ§Ãµes do usuÃ¡rio
- Respostas contextualizadas sobre a empresa
- Sistema de cache para respostas frequentes
- Comandos especiais para administraÃ§Ã£o
- EstatÃ­sticas de uso em tempo real

**Execute o setup:**
```bash
python setup_personalization.py
python test_personalized_chatbot.py
python app.py
```

**Na prÃ³xima seÃ§Ã£o**, vamos configurar o monitoramento e manutenÃ§Ã£o para garantir que o chatbot funcione perfeitamente em produÃ§Ã£o!
